#!/bin/bash
# Copyright 2014 Cumulus Networks, Inc. All rights reserved.
# Author: Trapier Marshall, trapier@cumulusnetworks.com
# https://stash.cumulusnetworks.com/users/trapier/repos/2x_upgrade_script/browse/2x_upgrade_script
#
#   References:
#   - https://support.cumulusnetworks.com/hc/en-us/articles/201787826-What-Files-should-I-Back-Up-when-Updating-Cumulus-Linux-via-Image-Install-
#   - https://support.cumulusnetworks.com/hc/en-us/articles/202313473-Upgrading-Cumulus-Linux
#
#   README:
#   This script copies files specified in a configuration file directly
#   between slots without using /mnt/persist, mitigating the risks
#   associated with forgetting to maintain the state /mnt/persist.
#
#   To Run:
#
#   root@sw1# bash 2x_upgrade_script
#
#   If it does not exist the first run will create a configuration file
#   /mnt/persist/slotsync.conf.  Uncomment entries there and run again to
#   actually copy files.
#
#   root@sw1# bash 2x_upgrade_script 
#   Copied 1 files to slot 2.
#
#   root@sw1:~ #
#


# configuration file location
SYNC_CONFIG="/etc/slotsync.conf"


# helper function to clean up on exit
function clean_tmp {
    rm $temp_include
    rm $temp_exclude
    if [[ $storage = "overlayfs" ]]; then
        umount $temp_initramfs_mount/ro_mount &>/dev/null
        umount $temp_initramfs_mount/$target_slot_dir &>/dev/null
        umount $temp_initramfs_mount/proc &>/dev/null
        umount $temp_initramfs_mount/dev &>/dev/null
        umount $temp_initramfs_mount &>/dev/null
        rmdir $temp_initramfs_mount &>/dev/null
        umount $temp_ro_mount &>/dev/null
        rmdir $temp_ro_mount &>/dev/null
        rm $temp_initramfs &>/dev/null
    fi
}


not_root=0
unconfigured=0

if [ $EUID -ne 0 ]; then
    not_root=1
fi

if [ ! -r "$SYNC_CONFIG" ]; then
    unconfigured=1
fi

# Help
if [ "$#" -ne 0 ]; then
    echo "USAGE: $(basename $0)"
    echo "Utility to copy files from the currently active slot to the other slot."
    echo "Accepts no command line arguments."
    if [[ $not_root -eq 1 && $unconfigured -eq 1 ]]; then
        echo -n "Run again with root privileges and no arguments then see "
    elif [[ $unconfigured -eq 1 ]]; then
        echo -n "Run again with no arguments and then see "
    else
        echo -n "See "
    fi
    echo "$SYNC_CONFIG for details."
    echo
    exit 1
fi

# Need root priviledges to run this script
if [ $not_root -eq 1 ]; then
   echo "You must have root privileges to run this command." 1>&2
   exit 1
fi

# if it doesn't exist, create configuration file with commented examples
if [ $unconfigured -eq 1 ]; then
    echo "## $SYNC_CONFIG" > "$SYNC_CONFIG"
    echo "####################################################################" >> "$SYNC_CONFIG"
    echo "## Configuration file for $(basename $0)" >> "$SYNC_CONFIG"
    echo "##" >> "$SYNC_CONFIG"
    echo "## A list of files and directories, one per line." >> "$SYNC_CONFIG"
    echo "## Directories are copied recursively." >> "$SYNC_CONFIG"
    echo "## To explicitly exclude a file or directory, start a line with '-'." >> "$SYNC_CONFIG"
    echo "## Comments start with #. Uncomment examples below to enable them." >> "$SYNC_CONFIG"
    echo "####################################################################" >> "$SYNC_CONFIG"
    echo  >> "$SYNC_CONFIG"
    for example in 'motd' 'hostname' 'resolv.conf' 'network/interfaces' \
        'quagga/' 'ssh/' 'passwd' 'group' 'shadow' 'cumulus/ports.conf' 'ldap.conf' \
        'network/interfaces.d/' 'nsswitch.conf'; do
        echo "#/etc/$example" >> "$SYNC_CONFIG"
    done
    echo "Configuration file $SYNC_CONFIG must exist. A commented-out example has"
    echo "been created with the following contents:"
    echo
    cat $SYNC_CONFIG
    exit 1
fi

# error out if mgmt vrf or namespace are enabled
if ip netns list | grep -q mgmt; then
    echo "Error: management namespace is enabled.  Unsupported configuration."
    exit 2
fi
if test -e /usr/sbin/cl-mgmtvrf && cl-mgmtvrf -s &>/dev/null ; then
    echo "Error: management VRF enabled.  Unsupported configuration."
    exit 2
fi

# determine the number of the currently active slot
active_slot=$(/usr/cumulus/bin/cl-img-select |awk '/^active/ {print $4}')
inactive_slot=$(/usr/cumulus/bin/cl-img-select |awk '! /^active/ {print $2}')

# detect if using lvm (arm,x86) or overlay (ppc)
rootdev=$(awk '$2 ~ /^\/$/ && $1 != "rootfs" {print $1}' /proc/mounts)
case $rootdev in
    overlayfs:root)
        storage="overlayfs"
        ;;
    /dev*)
        if [[ $(basename $(readlink $rootdev)) =~ dm-[[:digit:]]+ ]]; then
            storage="lvm"
        else
            echo "Unknown storage type"
            exit 1
        fi
        ;;
    *)
        echo "Unknown storage type"
        exit 1
        ;;
esac

trap "clean_tmp" EXIT

# Set up inactive slot and map source and target for copying
# If lvm-based mount up secondary slot (if not already mounted)
if [ $storage = "lvm" ]; then
    source_slot_dir="/"
    strip_dir_count=0

    # lifted from -u code as of cumulus.git:1fb48c1f
    exclude="
    /dev
    /proc
    /sys
    /run
    /var/lib/apt
    /var/lib/dpkg
    /var/lib/cumulus
    /etc/fstab
    /etc/lvm/backup
    /etc/lvm/archive
    /tmp
    "

    inactive_lv=CUMULUS-SYSROOT$inactive_slot
    target_slot_dir=$(lsblk -r | \
      awk "/$inactive_lv/ && NF==8 {print \$NF}")
    if [[ -n $target_slot_dir ]]; then
        inactive_mounted=$target_slot_dir
    else
        inactive_mount=$(mktemp -dp /tmp -t slot${inactive_slot}_XXXX )
        mount /dev/mapper/$inactive_lv $inactive_mount
        target_slot_dir=$inactive_mount
    fi
else # overlayfs
    source_slot_dir="/"
    target_slot_dir="/mnt/root-rw/config$inactive_slot"
    strip_dir_count=0


    # lifted from -u code as of cumulus.git:e772976b
    exclude="
    /dev
    /proc
    /sys
    /run
    /var/lib/apt
    /var/lib/dpkg
    /var/lib/cumulus
    /mnt
    /etc/lsb-release
    /etc/cumulus/init/lsb-release
    "

    # go ahead and clear the overlay since installation didn't do it for us
    rm -rf $target_slot_dir/*

    source /etc/cumulus/init/running/platform.conf
    if [[ $inactive_slot -eq 1 ]]; then
        inactive_ropart=$ro_part1
    else
        inactive_ropart=$ro_part2
    fi
    temp_ro_mount=$(mktemp -dp /tmp -t tmp_ro_mountXXXX )
    mount -t $ro_type -o $ro_opts /dev/$inactive_ropart $temp_ro_mount
    if ! diff $temp_ro_mount/etc/lsb-release "$target_slot_dir/etc/cumulus/init/lsb-release" &>/dev/null; then
        # init_rw_dir in the inactive slot's initramfs will clear the
        # overlay on firstboot, erasing the files we are about to copy
        # there. We have to initialize the overlay now to prevent this.
        # mount up the inactive ro, extract its initramfs, and chroot into
        # the functions we need.

        # Mount the inactive ro and extract initramfs from its uImage.
        # Assume initramfs is the first itb property value with "XZ
        # Compressed" magic number.  itb file format reference:
        # - https://git.kernel.org/cgit/utils/dtc/dtc.git/plain/Documentation/manual.txt?id=HEAD

        XZMAGIC=fd377a58
        STRUCT_POINTER_OFFSET=8

        uImage=$temp_ro_mount/boot/uImage.itb
        declare -A word

        map_word () {
            word[addr]=$1
            word[value]=$2
        }

        map_hex_word_at_cursor() {
            map_word $(hexdump -s$cursor -n4 -e '/4 "%_ad"' -e '/4 " %x"' $uImage)
        }

        map_uint_word_at_cursor() {
            map_word $(hexdump -s$cursor -n4 -e '/4 "%_ad"' -e '/4 " %u"' $uImage)
        }

        cursor_forward() {
            cursor=$(($cursor + $1))
        }

        # cursor = 0
        cursor=0

        # set cursor to location of struct pointer offset
        cursor_forward $STRUCT_POINTER_OFFSET
        # read structure offset (4 bytes), and move cursor to structure
        cursor=$(hexdump -s$cursor -n4 -e '/4 "%u"' $uImage)

        map_uint_word_at_cursor # read value at cursor

        # while true
        while true; do
            while [[ ${word[value]} -ne 3 ]]; do # while 4-byte uint at cursor not 3
                cursor_forward 4                 #     cursor forward four bytes
                map_uint_word_at_cursor          #     read 4-byte uint at cursor
            done
            cursor_forward 4                     # cursor forward 4 bytes
            map_uint_word_at_cursor              # read uint size (4 bytes)
            size=${word[value]}
            cursor_forward 8                     # cursor forward 8 bytes
            # if 4-bytes at cursor match 7zip magic
            #     dd from cursor to (cursor + size)
            #     exit
            # else
            #     cursor forward size bytes
            #     read value at cursor
            map_hex_word_at_cursor
            if [[ "${word[value]}" = "$XZMAGIC" ]];  then
                temp_initramfs=$(mktemp -p /tmp -t tmp_initramfsXXXX )
                dd if=$uImage of=$temp_initramfs bs=1 skip=${word[addr]} count=$size &>/dev/null
                break
            else
                cursor_forward $(($size + 4 - $size % 4))
                map_uint_word_at_cursor
            fi
        done

        # unpack with cpio from initramfs busybox tools under /mnt/initramfs
        temp_initramfs_mount=$(mktemp -dp /tmp -t tmp_initramfs_mountXXXX )
        mount -t tmpfs none $temp_initramfs_mount
        cd $temp_initramfs_mount && xzcat $temp_initramfs | /mnt/initramfs/bin/cpio -id 2>/dev/null && cd - > /dev/null
        # chroot into initramfs and run functions needed to initialize the
        # target overlay
        mkdir -p $target_slot_dir/etc/cumulus/init
        mkdir -p $temp_initramfs_mount/$target_slot_dir
        mkdir -p $temp_initramfs_mount/ro_mount
        mount -o bind,ro $temp_ro_mount $temp_initramfs_mount/ro_mount
        mount -o bind $target_slot_dir $temp_initramfs_mount/$target_slot_dir 
        mount -t proc none $temp_initramfs_mount/proc
        mount -o bind /dev $temp_initramfs_mount/dev
        chroot $temp_initramfs_mount /bin/sh -c "ro_rootmnt=ro_mount script_dir=scripts \
          source scripts/functions; make_fw_env_config; init_platform_path; init_rw_dir $target_slot_dir"
        cp $temp_ro_mount/etc/lsb-release $target_slot_dir/etc/cumulus/init/
    fi
fi

# create temporary files for parsing slotsync.conf
temp_include=$(mktemp --tmpdir=/tmp include.XXXXXX)
temp_exclude=$(mktemp --tmpdir=/tmp exclude.XXXXXX)

# always copy config file to other slot
echo "${source_slot_dir}${SYNC_CONFIG}" > "$temp_include"

# parse includes out of slotsync.conf
sed "/^-/d;                 # remove lines beginning with '-'
     s:#.*::;               # remove everything after a hash
     /^$/d;                 # delete empty lines
     s:\(^\s*\|\s*$\)::g;   # remove leading and trailing whitespace
     s:^:$source_slot_dir:  # prepend the source_slot_dir to every line" \
     "$SYNC_CONFIG" >> "$temp_include"

# excludes defaults, and append any configured excludes
# to be excluded with "tar -X"
echo "$exclude" | sed "s:^\s*::; /^$/d; s:^:$source_slot_dir:" > "$temp_exclude"
exclude_args="-X $temp_exclude"
if grep -q '^-' $SYNC_CONFIG; then
    sed -n "s:#.*::;                    # remove everything after a hash
            s:\(^\s*\|\s*$\)::g;        # remove leading and trailing whitespace
            s:/$::;                     # remove trailing slash
            /^-/s:^-:$source_slot_dir:p # on lines with '-', replace - with source_slot_dir
                                        #   then print the line" \
            "$SYNC_CONFIG" >> "$temp_exclude"
fi

# copy specified files and directories.  conceptually:
# "tar create from temp_include list (optionally excluding some) |tar extract to target_slot_dir"
file_list=$(
    tar -cmT "$temp_include" $exclude_args -f - 2>/dev/null |
    tar -C "$target_slot_dir" --strip-components="$strip_dir_count" -xvf -
)
file_count=$(($(echo "$file_list" |wc -l) -1))

mkdir -p $target_slot_dir/var/log
date >> $target_slot_dir/var/log/$(basename $0).log

cat - << EOUTPUT | tee -a $target_slot_dir/var/log/$(basename $0).log
Using config file: $SYNC_CONFIG
Copied the following files to slot $inactive_slot.

$(echo "$file_list" | sed 's:^:  /:')

$file_count files copied to slot $inactive_slot.
Slot $inactive_slot accessible under directory: $target_slot_dir/

Reminder: if used in the context of up/downgrade this script must be
used *after* cl-img-install in order to be effective.
EOUTPUT
