#!/usr/bin/env python

import sys, getopt
import subprocess
import re
import os
from pprint import pprint 
from pprint import pformat


#To do's
# 2) backup archive option
# 7) Check if root or sudo and warn/exit if not
# 4) Call slotsync script
# 5) Package into deb with slotsync - upgrade-tools  (Ben)

#X 1) implement arg processing
#X 3) Create slotsync file
#X 6) Exclude dir list implementation
#X 6) Refactor main into 1-2 smaller functions

# Define blacklist filenames with commment data



def check_blacklist(file_dct, debug=None):
    # For more detailed information refer to this User Guide document:
    #https://docs.cumulusnetworks.com/display/DOCS/Troubleshooting+the+etc+Directory
    
    # The Blacklist attempts a longest match.  e.g. if you add '/etc' to this list,
    #  the entire /etc dir would be excluded (i.e. don't do that)

    # Blacklist directory names should not contain a trailing slash
    blacklist_dct={
        '/etc/adjtime': 'System clock adjustment data - let ntp manage, in case switch hardware is replaced',
        '/etc/bcm.d': 'Per platform hardware config dir, created on first boot.  Do not copy',
        '/etc/blkid.tab': 'Partition table - should not be modified manually',
        '/etc/blkid.tab.old': 'a previous partition table - should not be modified manually',
        '/etc/cumulus/init': 'Platform hardware specific files.  Do not copy',
        '/etc/default/clagd': 'Created and managed by ifupdown2. Do not copy',
        '/etc/default/grub': 'Grub init table should not be modified manually',
        '/etc/default/hwclock': 'Platform hardware specific file.  Created during first boot. Do not copy',
        '/etc/default/hwclock.ucf-dist': 'Old merge conflict file, see RN-301 in 2.5.3',
        '/etc/default/phy_ucode_update': 'Created during first boot.  Do not copy',
        '/etc/init': 'Platform initialization files. Do not copy',
        '/etc/init.d': 'Platform initialization files.  Do not copy',
        '/etc/lsb-release' : 'System version data.  Do not copy',
        '/etc/lvm/archive': 'Filesystem files.  Do not copy',
        '/etc/lvm/backup': 'Filesystem files. Do not copy',
        '/etc/modules': 'Created during first boot.  Do not copy',
        '/etc/os-release' : 'System version data. Do not copy',
        '/etc/sensors.d': 'Platform specific sensor data. Created during first boot. Do not copy',
        '/etc/update-tools-debug.log': 'Debug log for this script. Do not copy'
    }
    allowed_file_dct={}
    if debug:
        debug.write('\n------------------------------\nBlacklist Processing:\n')
        
    for filename in sorted(file_dct):
        please_blacklist=None
        #if (filename not in blacklist_dct) and ( os.path.dirname(filename) not in blacklist_dct ):
            # file or its dir is not blacklisted, return the filename
        #    allowed_file_dct[filename]=''
            #comment=blacklist_dct.get(filename,None)
            #if not comment:
            #    comment=blacklist_dct.get(os.path.dirname(filename),'None')
        for blacklist_name in sorted(blacklist_dct):
            #check for longest match available in blacklist name.
            #e.g. if a dir is blacklisted, block all files in it
            if debug:
                debug.write('searching: blacklist item {0}  in {1}\n'.format(blacklist_name, filename))
            if ( re.search( blacklist_name, filename)):
                if debug:
                    debug.write('{0} Matches Blacklist, ignoring\n'.format(blacklist_name))
                please_blacklist=True  
                break
            
        if not please_blacklist:
            allowed_file_dct[filename]=''

    return allowed_file_dct    


# Define whitelist filenames with comment data

def check_whitelist(file_dct, debug):
    # The whitelist is only checked on files that were added since the binary was installed
    # Unlike the Blacklist, the Whitelist must match all the way to the last directory name
    # or the exact file name.

    # For more detailed information refer to this User Guide document:
    #https://docs.cumulusnetworks.com/display/DOCS/Troubleshooting+the+etc+Directory

    # White list directories should not contain a trailing slash
    whitelist_dct={
        '/etc/apt': 'apt-get configuration file directory',
        '/etc/apt/sources.list.d': 'apt-get sources directory',
        '/etc/cumulus/.license' : 'Post 2.5.2 license file',
        '/etc/cumulus/.license.txt' : 'Pre-2.5.2 license file',
        '/etc/cumulus/ports.conf' : 'Front-panel interface definition',
        '/etc/cumulus/acl/policy.d': 'cl-acltool policies modified by user',
        '/etc/cumulus/ssmonitor.d': 'jdoo config files for daemon monitoring',
        '/etc/default/isc-dhcp-relay' : 'DHCP relay config file',
        '/etc/hostname' : 'Hostname file.  May be set manually here or via DHCP',
        '/etc/motd' : 'Message of the day',
        '/etc/nsswitch.conf' : '',
        '/etc/network': 'All the config for the switch interfaces',
        '/etc/passwd' : 'System password file',
        '/etc/ptm.d': 'PTM daemon topology files',
        '/etc/quagga' : 'Quagga config files',
        '/etc/resolv.conf': 'DNS Resolver config.  Only include if modified and not using DHCP on eth0',
        '/etc/shadow' : 'System password file',
        '/etc/ssh' : 'ssh config files',
        '/etc/sysctl.d' : 'sysctl control options',
        '/etc/slotsync.conf': 'upgrade tool config file to copy config files to alternate slot.  Use this tool to configure that file',
        '/home' : 'home directories for users',
        '/root' : 'root user home directory'
    }

    whitelisted_file_dct={}
    if debug:
        debug.write('\n------------------------------\nWhitelist Processing:\n')

    for filename in file_dct:
        comment=None
        if (filename.rstrip('/') in whitelist_dct) or ( os.path.dirname(filename).rstrip('/') in whitelist_dct ):
            # file or its dir is whitelisted, return a comment
            if debug:
                debug.write('Whitelisting: {0}\n'.format(filename))

            comment=whitelist_dct.get(filename,None)
            if not comment:
                comment=whitelist_dct.get(os.path.dirname(filename).rstrip('/'),None)

            whitelisted_file_dct[filename]=comment
        else:
            whitelisted_file_dct[filename]='File added/changed by admin or 3rd party app'
    
    return whitelisted_file_dct


def check_exclude_list(file_dct, exclude_list, debug=None):
    allowed_file_dct={}
        
    # The exclude list attempts a longest match.  e.g. if you add '/etc' to this list,
    #  the entire /etc dir would be excluded (i.e. don't do that)
    if debug:
        debug.write('\n------------------------------\nExclude List Processing:\n')

    for filename in sorted(file_dct):
        please_exclude=None
        for exclude_name in sorted(exclude_list):
            #check for longest match available in blacklist name.
            #e.g. if a dir is blacklisted, block all files in it
            if debug:
                debug.write('searching: Exclude list item {0}  in {1}\n'.format(exclude_name.strip().rstrip('/'), filename))
            if ( re.search( exclude_name.strip().rstrip('/'), filename)):
                if debug:
                    debug.write('{0} Matches Exclude list. Ignoring\n'.format(exclude_name.strip().rstrip('/')))
                please_exclude=True  
                break
            
        if not please_exclude:
            allowed_file_dct[filename]=''

    return allowed_file_dct    
    

def files_to_determine():
    #These files need to be determined if they should be on whitelist, blacklist or neither
    '''
    /etc/sysctl.d/*
    /etc/watchdog.d/*
    /etc/bash_completion.d/*  (git, vxfldcommon, vxrdctl)
    '''
    
def usage():
    
    print "Usage:  Determine changed config files in order to backup or sync to other slot"
    print "{0:<15}: {1}".format(" no args", "Default: Print output of changed config files to screen")
    print "{0:<15}: {1}".format("-b, --backup", "Create a backup archive of changed config files")
    print "{0:<15}: {1}".format("-n, --dryrun", "Output to screen but don't create any files")
    print "{0:<15}: {1}".format("-q, --quiet", "No output to screen, only create any files requested ")    
    print "{0:<15}: {1}".format("-s, --sync", "Create /etc/slotsync.conf file and call slotsync to move file to alternate slot")
    print "{0:<15}: {1}".format("-f, --force", "Used with -s. Do not ask before running slotsync and moving files")
    print "{0:<15}: {1}".format("-x, --exclude dirs", "Exclude a comma separated list of dirs: e.g.  -x /root,/home")
    print "{0:<15}: {1}".format("-h, --help", "Show this message")


def get_ppc_files(debug=None):
    install_list_dct={}
    install_list_pattern=re.compile(r'''(?P<permissions>[rwxsStT-]+)
                                    \s+(?P<link_count>[0-9]+)
                                    \s+(?P<owner>\w+)
                                    \s+(?P<group>\w+)
                                    \s+(?P<size>\d+)
                                    \s+(?P<date>[0-9\-]+)
                                    \s+(?P<time>[0-9:]+)
                                    \.(?P<msec>[0-9]+)
                                    \s+(?P<timezone>[\+\-0-9]+)
                                    \s+
                                    '''+'/mnt/root\-ro(?P<filename>\S+)', re.X)
        
    # Get active slot
    #active => slot 2 (alt    ): 2.5.2-727a0c6-201504132128-build
    # or
    #active => slot 1 (primary): 2.5.5-4cd66d9-201512071810-build

    slot_pattern=re.compile('active\s+\=\>\s+slot\s+(?P<slot>[12]+)')
    cl_img_select=subprocess.check_output('cl-img-select')
    match=slot_pattern.search(cl_img_select)
    if match:
        slot='config{}'.format(match.group('slot'))
        # find all files in /etc /home /root in locally installed files and store
        local_list_raw=subprocess.check_output(['find',
                                                '/mnt/root-rw/{0}/etc'.format(slot),
                                                '/mnt/root-rw/{0}/home'.format(slot),
                                                '/mnt/root-rw/{0}/root'.format(slot),
                                                '-type', 'f',
                                                '-exec', 'ls', '-l', '--full-time', '{}', ';'])
        
        install_list_raw=subprocess.check_output(['find',
                                                '/mnt/root-ro/etc',
                                                '/mnt/root-ro/home',
                                                '/mnt/root-ro/root',
                                                '-type', 'f',
                                                '-exec', 'ls', '-l', '--full-time', '{}', ';'])
        
       
        #Output sample:
        #-rw-r--r-- 1 root root 580 2016-02-03 18:48:58.752711375 +0000 /etc/network/interfaces
        
        
        for install_line in install_list_raw.split('\n'):
            match=install_list_pattern.match(install_line)
            if match:
                install_filename=match.group('filename')
                install_datetime='{} {}'.format(match.group('date'), match.group('time'))
                install_size=match.group('size')
                install_list_dct[install_filename]={ 'size': install_size, 'datetime' : install_datetime }
 
    else:
        print('Error: Could not match active slot in cl-img-select')
        sys.exit(1)
        
        
    #End get_ppc_files()     
    return install_list_dct, local_list_raw


def get_x86_files(debug=None):

    install_list_dct={}    
    installer_file='/var/lib/cumulus/installer/onie-installer'

    #Setup Regex's to parse the tar output
    #File sample:
    #-rw-r--r-- 105/107         111 2015-10-10 02:36:51 ./etc/quagga/bgpd.conf
    install_file_pattern=re.compile(r'''(?P<permissions>\-[rwxsStT-]+)
                                    \s+(?P<owner>\w+)
                                    /(?P<group>\w+)
                                    \s+(?P<size>\d+)
                                    \s+(?P<date>[0-9\-]+)
                                    \s+(?P<time>[0-9:]+)
                                    \s+\.(?P<filename>\S+)
                                    ''', re.X)
    
    # link sample
    #lrwxrwxrwx 0/0               0 2015-12-08 02:12:16 ./etc/alternatives/rlogin.1.gz -> /usr/share/man/man1/slogin.1.gz
    install_link_pattern=re.compile('^l')
    
    #directory sample
    #drwxr-xr-x 0/0               0 2015-02-22 11:38:03 ./etc/ld.so.conf.d/
    install_dir_pattern=re.compile('^d')
    
    #blank line
    install_blank_pattern=re.compile('^\W*$')
 
 
    # untar sysroot partition file data and store
    #Note, use import shlex; command_line= raw_input(); args=shlex.split(command_line) to sort out subprocess args
    
    tmp_dir=subprocess.check_output(['mktemp',  '-d']).rstrip('\n')
    print('tmp_dir is {0}'.format(tmp_dir))
    subprocess.call(['sh', installer_file, 'extract', tmp_dir])
    # This doesn't work, but we may not care...
    #subprocess.call(['cd', tmp_dir])
    
    # Actual command line to get the list of files out of the tar:
    '''
    tar -t -v --exclude=bin --exclude=boot --exclude=usr --exclude=sbin --exclude=dev --exclude=run --exclude=var
       --exclude=lib --full-time -f sysroot-release.tar.gz | egrep -v -- '^d|->'
    '''
    
    install_list_raw=subprocess.check_output(['tar', '-t', '-v',
                                             '--exclude=bin',
                                             '--exclude=boot',
                                             '--exclude=usr',
                                             '--exclude=sbin',
                                             '--exclude=dev',
                                             '--exclude=run',
                                             '--exclude=var',
                                             '--exclude=lib',
                                             '--full-time',
                                             '-f', 'sysroot-release.tar.gz'],
                                             cwd=tmp_dir)
    
    for install_line in install_list_raw.split('\n'):
        #if debug:
        #    debug.write('Processing install line {}\n'.format(install_line))
            
        match=install_file_pattern.match(install_line)
        if match:
            install_filename=match.group('filename')
            install_datetime='{} {}'.format(match.group('date'), match.group('time'))
            install_size=match.group('size')
            install_list_dct[install_filename]={ 'size': install_size, 'datetime' : install_datetime }
            
        elif install_link_pattern.match(install_line):
            # This is a link.  Put in a separate list to check later
            pass
        
        elif install_dir_pattern.match(install_line):
            # This is a directory. ignore
            pass
            
        elif install_blank_pattern.match(install_line):
            #Blank line. Ignore
            pass
    
        else:
            # No match
            print('Error: Installed image filename, date, and size not parsed correctly.')
            print('Line: #'+install_line+'#')
            print('Decide what to do here... exit or continue')
            
    if debug:
        debug.write('--------------------------\ninstall_list_dct:\n')
        debug.write(pformat(install_list_dct))
    
    # find all files in /etc /home /root in locally installed files and store
    local_list_raw=subprocess.check_output(['find',
                                            '/etc',
                                            '/home',
                                            '/root',
                                            '-type', 'f',
                                            '-exec', 'ls', '-l', '--full-time', '{}', ';'])
    #Output sample:
    #-rw-r--r-- 1 root root 580 2016-02-03 18:48:58.752711375 +0000 /etc/network/interfaces
    
    # End get_x86_files()
    return install_list_dct, local_list_raw

def create_slotsync_conf(added_file_dct, changed_file_dct, force):
    slotsync_fn='/etc/slotsync.conf'
    upgrade_script_fn='2x_upgrade_script'
    prev_slotsync='/etc/slotsync.bak'
    # backup the previous slotsync file if exists
    if os.path.exists(slotsync_fn):
        os.rename(slotsync_fn, prev_slotsync)
        
    slotsync_file=open(slotsync_fn, 'w')
    
    slotsync_file.write('## ' + slotsync_fn + '\n')
    slotsync_file.write('''
####################################################################
## Configuration file for ''' + upgrade_script_fn + '''
##
## A list of files and directories, one per line.
## Directories are copied recursively.
## To explicitly exclude a file or directory, start a line with '-'.
## Comments start with #. Uncomment examples below to enable them.
####################################################################

''')
    
    slotsync_file.write('# Files Added since install\n')
    for added_file in sorted(added_file_dct):
        slotsync_file.write('{0}\n'.format(added_file))
        
    slotsync_file.write('\n')
    slotsync_file.write('# Files Changed since install\n')
    for changed_file in sorted(changed_file_dct):
        slotsync_file.write('{0}\n'.format(changed_file))
        
    slotsync_file.close()
    
        
def create_backup_tar(added_file_dct, changed_file_dct, arch, force):
    pass

def process_exclude_list(exclude_arg):
    exclude_list=exclude_arg.split(',')
    return(exclude_list)


def main(argv):
    
    force=False
    backup=False
    debug=False
    sync=False
    dryrun=False
    quiet=False
    exclude_list=[]
    
    try:
        opts, args = getopt.getopt(argv,"hbdfnqsx:",["help", "backup", "debug",
                                                     "force", "dryrun", "quiet",
                                                     "sync", "exclude="])
    except getopt.GetoptError:
        usage()
        sys.exit(2)
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage()
            sys.exit()
        elif opt in ("-b", "--backup"):
            backup=True
        elif opt in ("-d", "--debug"):
            debug=open('/etc/update-tools-debug.log', 'w')
            
        elif opt in ("-f", "--force"):
            force=True 
        elif opt in ("-n", "--dryrun"):
            dryrun=True
        elif opt in ("-q", "--quiet"):
            quiet=True
        elif opt in ("-s", "--sync"):
            sync=True
        elif opt in ("-x", "--exclude"):
            print('Exclude arg is {}'.format(arg))
            exclude_list=process_exclude_list(arg)
            print('Exclude list is {0}'.format(exclude_list))
        else:
            print("Bug: Unhandled option")
            sys.exit()
    
    # setup variables - debug(store data in local files), string lists
    install_list_dct={}
    local_list_dct={}
    added_file_dct={}
    changed_file_dct={}
    deleted_file_dct={}
    tmp_dir=None
    blank_line_pattern=re.compile('^\W*$')

    if debug and not quiet:
        print('Creating debug log file in /etc/update-tools-debug.log')
    
    # Collect all the file data:
    # find and extract install file based on arch
    
    # run uname -a
    arch=subprocess.check_output(['uname', '-m']).rstrip('\n')
    
    if arch == "ppc":
        install_list_dct, local_list_raw = get_ppc_files(debug)
        local_list_pattern=re.compile(r'''(?P<permissions>[rwxsStT-]+)
                                    \s+(?P<link_count>[0-9]+)
                                    \s+(?P<owner>\w+)
                                    \s+(?P<group>\w+)
                                    \s+(?P<size>\d+)
                                    \s+(?P<date>[0-9\-]+)
                                    \s+(?P<time>[0-9:]+)
                                    \.(?P<msec>[0-9]+)
                                    \s+(?P<timezone>[\+\-0-9]+)
                                    \s+
                                    '''+'/mnt/root\-rw/'+slot+'(?P<filename>\S+)', re.X)

     
     
       # End if arch=ppc
       
       
    if arch == 'arm':
        #TBD - probably will look like x86
        pass
     
    
    if arch == 'x86_64':
        install_list_dct, local_list_raw = get_x86_files(debug)
        local_list_pattern=re.compile(r'''(?P<permissions>[rwxsStT-]+)
                                      \s+(?P<link_count>[0-9]+)
                                      \s+(?P<owner>\w+)
                                      \s+(?P<group>\w+)
                                      \s+(?P<size>\d+)
                                      \s+(?P<date>[0-9\-]+)
                                      \s+(?P<time>[0-9:]+)
                                      \.(?P<msec>[0-9]+)
                                      \s+(?P<timezone>[\+\-0-9]+)
                                      \s+(?P<filename>\S+)
                                      ''', re.X)
      
    
    
    # Loop through all local files and determine adds, changes, deletes. 
    for local_line in local_list_raw.split('\n'):
        comment=None
        match=local_list_pattern.match(local_line)
        if match:
            local_filename=match.group('filename')
            local_datetime='{} {}'.format(match.group('date'), match.group('time'))
            local_size=match.group('size')
            local_list_dct[local_filename]={ 'size': local_size, 'datetime' : local_datetime }
            if local_filename in install_list_dct:
                #File exists in both places.  Check to see if it has been modified
                install_datetime=install_list_dct[local_filename]['datetime']
                install_size=install_list_dct[local_filename]['size']
                if ( local_size != install_size) or ( local_datetime != install_datetime):
                    #File has been changed
                    changed_file_dct[local_filename]=''
     
            else:
                #local file not installed by installer, it is an added file
                added_file_dct[local_filename]=''

        elif blank_line_pattern.match(local_line):
            #Blank line. Ignore
            pass
        
        else:
            print('Error: Local filename, date, and size not parsed correctly.')
            print('Local Line: #'+local_line+'#')
            print('Decide what to do here... exit or continue')
     
    if debug:
        debug.write('\n------------------------------\nTemp added file list:\n')
        debug.write(pformat(added_file_dct))
        debug.write('\n------------------------------\nTemp changed file list:\n')
        debug.write(pformat(changed_file_dct))
    
    # Cannot determine this on ppc, so only check x86
    # Loop through installed files and flag any files that have been deleted
    # This may be a pointless exercise and can be safely removed
    if arch=='x86_64':
        for install_filename in sorted(install_list_dct):
            if install_filename not in local_list_dct:
                deleted_file_dct[install_filename]="Note: File has been deleted since original binary install"
     
       
    #Remove tmp_dir here to save space in case of crash
    # comment line to debug
    if tmp_dir:
        subprocess.call(['rm', '-rf', tmp_dir])
    
    # End if arch=x86
    
    # Loop through adds and compare to blacklist, whitelist.  Mark others as 3rd party
    added_file_dct=check_blacklist(added_file_dct, debug)
    added_file_dct=check_exclude_list(added_file_dct, exclude_list, debug)
    added_file_dct=check_whitelist(added_file_dct, debug)
    
    # Loop through changes and compare to blacklist
    changed_file_dct=check_blacklist(changed_file_dct, debug)
    changed_file_dct=check_exclude_list(changed_file_dct, exclude_list, debug)
    # The only reason to check changed files against whitelist is to mark them with comments.
    # if they were changed and not blacklisted, they are important
    changed_file_dct=check_whitelist(changed_file_dct, debug)
    
    
    # Loop through deletes and compare to blacklist, whitelist
    # No need at this time
    
    # output results to screen and a slotsync.conf file
    if not quiet:
        print('Files Added since initial install:')
        for filename in sorted(added_file_dct):
            print('{0:<40}# {1}'.format(filename, added_file_dct[filename]))

        print('')
        print('Files Changed since initial install:')
        for filename in sorted(changed_file_dct):
            print('{0:<40}# {1}'.format(filename, changed_file_dct[filename]))
           
        if arch=='x86_64':    
            print('Files Deleted since initial install:')
            for filename in sorted(deleted_file_dct):
                print('{0:<40}# {1}'.format(filename, deleted_file_dct[filename]))

    if sync and not dryrun:
        create_slotsync_conf(added_file_dct, changed_file_dct, force)
        
    if backup and not dryrun:
        create_backup_tar(added_file_dct, changed_file_dct, arch, force)

    if debug:
        debug.close()

if __name__ == '__main__':
    main(sys.argv[1:])
    