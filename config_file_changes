#!/usr/bin/env python

import subprocess
import re
import os
from pprint import pprint 

# setup variables - debug(store data in local files), string lists
install_list_dct={}
local_list_dct={}
added_file_dct={}
changed_file_dct={}
deleted_file_dct={}

# Define whitelist filenames with comment data
# Define blacklist filenames with commment data

def check_blacklist(file_dct):
    # For more detailed information refer to this User Guide document:
    #https://docs.cumulusnetworks.com/display/DOCS/Troubleshooting+the+etc+Directory
    
    # The Blacklist attempts a longest match.  e.g. if you add '/etc' to this list,
    #  the entire /etc dir would be excluded (i.e. don't do that)

    # Blacklist directory names should not contain a trailing slash
    blacklist_dct={
        '/etc/adjtime': 'System clock adjustment data - let ntp manage, in case switch hardware is replaced',
        '/etc/bcm.d': 'Per platform hardware config dir, created on first boot.  Do not copy',
        '/etc/blkid.tab': 'Partition table - should not be modified manually',
        '/etc/blkid.tab.old': 'a previous partition table - should not be modified manually',
        '/etc/cumulus/init': 'Platform hardware specific files.  Do not copy',
        '/etc/default/clagd': 'Created and managed by ifupdown2. Do not copy',
        '/etc/default/grub': 'Grub init table should not be modified manually',
        '/etc/default/hwclock': 'Platform hardware specific file.  Created during first boot. Do not copy',
        '/etc/default/hwclock.ucf-dist': 'Old merge conflict file, see RN-301 in 2.5.3',
        '/etc/default/phy_ucode_update': 'Created during first boot.  Do not copy',
        '/etc/init': 'Platform initialization files. Do not copy',
        '/etc/init.d': 'Platform initialization files.  Do not copy',
        '/etc/lvm/archive': 'Filesystem files.  Do not copy',
        '/etc/lvm/backup': 'Filesystem files. Do not copy',
        '/etc/modules': 'Created during first boot.  Do not copy',
        '/etc/sensors.d': 'Platform specific sensor data. Created during first boot. Do not copy'
    }
    blacklisted_file_dct={}
        
    for filename in sorted(file_dct):
        please_blacklist=None
        #if (filename not in blacklist_dct) and ( os.path.dirname(filename) not in blacklist_dct ):
            # file or its dir is not blacklisted, return the filename
        #    blacklisted_file_dct[filename]=''
            #comment=blacklist_dct.get(filename,'None')
            #if not comment:
            #    comment=blacklist_dct.get(os.path.dirname(filename),'None')
        for blacklist_name in sorted(blacklist_dct):
            #check for longest match available in blacklist name.
            #e.g. if a dir is blacklisted, block all files in it
            print('searching: {0}  in {1}'.format(blacklist_name, filename))
            if ( re.search( blacklist_name, filename)):
                print('{0} Matches'.format(blacklist_name))
                please_blacklist=True  
                break
            
        if not please_blacklist:
            blacklisted_file_dct[filename]=''

    return blacklisted_file_dct    



def check_whitelist(file_dct):
    # The whitelist is only checked on files that were added since the binary was installed
    # Unlike the Blacklist, the Whitelist must match all the way to the last directory name
    # or the exact file name.

    # White list directories should not contain a trailing slash
    whitelist_dct={
        '/etc/apt': 'apt-get configuration file directory',
        '/etc/apt/sources.list.d': 'apt-get sources directory',
        '/etc/network': 'All the config for the switch interfaces',
        '/etc/cumulus/.license' : 'Post 2.5.2 license file',
        '/etc/cumulus/.license.txt' : 'Pre-2.5.2 license file',
        '/etc/cumulus/acl/policy.d': 'cl-acltool policies modified by user',
        '/etc/cumulus/ssmonitor.d': 'jdoo config files for daemon monitoring',
        '/etc/ptm.d': 'PTM daemon topology files',
        '/etc/slotsync.conf': 'upgrade tool config file to copy config files to alternate slot.  Use this tool to configure that file'
    }

    whitelisted_file_dct={}

    for filename in file_dct:
        comment=None
        if (filename in whitelist_dct) or ( os.path.dirname(filename) in whitelist_dct ):
            # file or its dir is whitelisted, return a comment
            comment=whitelist_dct.get(filename,'None')
            if not comment:
                comment=whitelist_dct.get(os.path.dirname(filename),'None')

            whitelisted_file_dct[filename]=comment
        else:
            whitelisted_file_dct[filename]='File added by admin or 3rd party app'
    
    return whitelisted_file_dct


def files_to_determine():
    #These files need to be determined if they should be on whitelist, blacklist or neither
    '''
    /etc/sysctl.d/*
    /etc/watchdog.d/*
    /etc/bash_completion.d/*  (git, vxfldcommon, vxrdctl)
    '''
    

# Collect all the file data:
# find and extract install file based on arch

# run uname -a
arch="x86"
if arch == "x86":
    installer_file='/var/lib/cumulus/installer/onie-installer'

if arch == "ppc":
    installer_file='unknown'

if arch == 'arm':
    installer_file=''
    

# untar sysroot partition file data and store
#Note, use import shlex; command_line= raw_input(); args=shlex.split(command_line) to sort out subprocess args

tmp_dir=subprocess.check_output(['mktemp',  '-d']).rstrip('\n')
print('tmp_dir is {0}'.format(tmp_dir))
subprocess.call(['sh', installer_file, 'extract', tmp_dir])
# This doesn't work, but we may not care...
#subprocess.call(['cd', tmp_dir])

# Actual command line to get the list of files out of the tar:
'''tar -t -v --exclude=bin --exclude=boot --exclude=usr --exclude=sbin --exclude=dev --exclude=run --exclude=var
   --exclude=lib --full-time -f sysroot-release.tar.gz | egrep -v -- '^d|->'
'''

install_list_raw=subprocess.check_output(['tar', '-t', '-v',
                                          '--exclude=bin',
                                          '--exclude=boot',
                                          '--exclude=usr',
                                          '--exclude=sbin',
                                          '--exclude=dev',
                                          '--exclude=run',
                                          '--exclude=var',
                                          '--exclude=lib',
                                          '--full-time',
                                          '-f', 'sysroot-release.tar.gz'],
                                          cwd=tmp_dir)
#File sample:
#-rw-r--r-- 105/107         111 2015-10-10 02:36:51 ./etc/quagga/bgpd.conf
install_file_pattern=re.compile(r'''(?P<permissions>\-[rwxsStT-]+)
                                \s+(?P<owner>\w+)
                                /(?P<group>\w+)
                                \s+(?P<size>\d+)
                                \s+(?P<date>[0-9\-]+)
                                \s+(?P<time>[0-9:]+)
                                \s+\.(?P<filename>\S+)
                                ''', re.X)

# link sample
#lrwxrwxrwx 0/0               0 2015-12-08 02:12:16 ./etc/alternatives/rlogin.1.gz -> /usr/share/man/man1/slogin.1.gz
install_link_pattern=re.compile('^l')

#directory sample
#drwxr-xr-x 0/0               0 2015-02-22 11:38:03 ./etc/ld.so.conf.d/
install_dir_pattern=re.compile('^d')

#blank line
install_blank_pattern=re.compile('^\s+$')

for install_line in install_list_raw.split('\n'):
    print('Install line {}'.format(install_line))
    match=install_file_pattern.match(install_line)
    if match:
        install_filename=match.group('filename')
        install_datetime='{} {}'.format(match.group('date'), match.group('time'))
        install_size=match.group('size')
        install_list_dct[install_filename]={ 'size': install_size, 'datetime' : install_datetime }
        continue    
    
    match=install_link_pattern.match(install_line)
    if match:
        # This is a link.  Put in a separate list to check later
        continue
    
    match=install_dir_pattern.match(install_line)
    if match:
        continue
        
    match=install_blank_pattern.match(install_line)
    if match:
        continue

    print('Error: Installed image filename, date, and size not parsed correctly from:')
    print(install_line)
    print('Decide what to do here... exit or continue')
        
pprint(install_list_dct)

# find all files in /etc /home /root in locally installed files and store
local_list_raw=subprocess.check_output(["find", '/etc', '/home', '/root', '-type', 'f', '-exec', 'ls', '-l', '--full-time', '{}', ';'])
#Output sample:
#-rw-r--r-- 1 root root 580 2016-02-03 18:48:58.752711375 +0000 /etc/network/interfaces

local_list_pattern=re.compile(r'''(?P<permissions>[rwxsStT-]+)
                              \s+(?P<link_count>[0-9]+)
                              \s+(?P<owner>\w+)
                              \s+(?P<group>\w+)
                              \s+(?P<size>\d+)
                              \s+(?P<date>[0-9\-]+)
                              \s+(?P<time>[0-9:]+)
                              \.(?P<msec>[0-9]+)
                              \s+(?P<timezone>[\+\-0-9]+)
                              \s+(?P<filename>\S+)
                              ''', re.X)

# Loop through all local files and determine adds, changes, deletes. 
for local_line in local_list_raw.split('\n'):
    comment=None
    match=local_list_pattern.match(local_line)
    if match:
        local_filename=match.group('filename')
        local_datetime='{} {}'.format(match.group('date'), match.group('time'))
        local_size=match.group('size')
        local_list_dct[local_filename]={ 'size': local_size, 'datetime' : local_datetime }
        if local_filename in install_list_dct:
            #File exists in both places.  Check to see if it has been modified
            install_datetime=install_list_dct[local_filename]['datetime']
            install_size=install_list_dct[local_filename]['size']
            if ( local_size != install_size) or ( local_datetime != install_datetime):
                #File has been changed
                changed_file_dct[local_filename]=''

        else:
            #local file not installed by installer, it is an added file
            added_file_dct[local_filename]=''

    else:
        print('Error: Local filename, date, and size not parsed correctly from:')
        print(local_line)
        print('Decide what to do here... exit or continue')

print('Debugging output only')
print('Temp added file list:')
pprint(added_file_dct)
print('Temp changed file list:')
pprint(changed_file_dct)

# Loop through installed files and flag any files that have been deleted
for install_filename in sorted(install_list_dct):
    if install_filename not in local_list_dct:
        deleted_file_dct[install_filename]="Note: File has been deleted since original binary install"


#Remove tmp_dir here to save space in case of crash
# comment line to debug
subprocess.call(['rm', '-rf', tmp_dir])

# Loop through adds and compare to blacklist, whitelist.  Mark others as 3rd party

# Loop through changes and compare to blacklist, whitelist

added_file_dct=check_blacklist(added_file_dct)
added_file_dct=check_whitelist(added_file_dct)

changed_file_dct=check_blacklist(changed_file_dct)
# No reason to check changed files against whitelist,
# since if they were changed and not blacklisted, they are important
# changed_file_dct=check_whitelist(changed_file_dct)


# Loop through deletes and compare to blacklist, whitelist
# No need at this time

# output results to screen and a slotsync.conf file
print('Files Added since initial install:')
for filename in sorted(added_file_dct):
    print('{0:<40}# {1}'.format(filename, added_file_dct[filename]))

print('Files Changed since initial install:')
for filename in sorted(changed_file_dct):
    print('{0:<40}# {1}'.format(filename, changed_file_dct[filename]))
    
print('Files Deleted since initial install:')
for filename in sorted(deleted_file_dct):
    print('{0:<40}# {1}'.format(filename, deleted_file_dct[filename]))

