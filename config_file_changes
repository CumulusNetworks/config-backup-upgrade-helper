#!/usr/bin/env python

import sys, getopt
import subprocess
import re
import os
import time
import shutil
from pprint import pprint 
from pprint import pformat
from sys import version_info


#To do's
# 7) Check if root or sudo and warn/exit if not
# 4) Call slotsync script
# 5) Package into deb with slotsync - upgrade-tools  (Ben)
# 10) Write readme.md file for repo with examples
# 11) Rename, and set log file to match new name
# 12) implement and test arch=arm
# 13) refactor debugging to use log facility?


#X 1) implement arg processing
#X 2) backup archive option
#X 3) Create slotsync file
#X 6) Exclude dir list implementation
#X 8) Refactor main into 1-2 smaller functions
#X 9) refactor main again - separate parse_opts


class opt(object):
    force=False
    backup=False
    #backup_dir default could be /mnt/persist/backup-configs, could be /tmp, could be /etc
    backup_dir='/mnt/persist/backup'
    create=False
    debug_fn='/var/log/' + sys.argv[0] + '.log'
    debug=False
    sync=False
    dryrun=False
    quiet=False
    exclude_list=[]
    slotsync_script='./slotsync'
    

def check_blacklist(file_dct):
    # For more detailed information refer to this User Guide document:
    #https://docs.cumulusnetworks.com/display/DOCS/Troubleshooting+the+etc+Directory
    
    # The Blacklist attempts a longest match.  e.g. if you add '/etc' to this list,
    #  the entire /etc dir would be excluded (i.e. don't do that)

    # Blacklist directory names should not contain a trailing slash
    blacklist_dct={
        '/etc/adjtime': 'System clock adjustment data - let ntp manage, in case switch hardware is replaced',
        '/etc/bcm.d': 'Per platform hardware config dir, created on first boot.  Do not copy',
        '/etc/blkid.tab': 'Partition table - should not be modified manually',
        '/etc/blkid.tab.old': 'a previous partition table - should not be modified manually',
        '/etc/cumulus/init': 'Platform hardware specific files.  Do not copy',
        '/etc/default/clagd': 'Created and managed by ifupdown2. Do not copy',
        '/etc/default/grub': 'Grub init table should not be modified manually',
        '/etc/default/hwclock': 'Platform hardware specific file.  Created during first boot. Do not copy',
        '/etc/default/hwclock.ucf-dist': 'Old merge conflict file, see RN-301 in 2.5.3',
        '/etc/default/phy_ucode_update': 'Created during first boot.  Do not copy',
        '/etc/init': 'Platform initialization files. Do not copy',
        '/etc/init.d': 'Platform initialization files.  Do not copy',
        '/etc/fstab': 'Static info on filesystem. Do not copy',
        '/etc/lsb-release' : 'System version data.  Do not copy',
        '/etc/lvm/archive': 'Filesystem files.  Do not copy',
        '/etc/lvm/backup': 'Filesystem files. Do not copy',
        '/etc/modules': 'Created during first boot.  Do not copy',
        '/etc/os-release' : 'System version data. Do not copy',
        '/etc/sensors.d': 'Platform specific sensor data. Created during first boot. Do not copy'
    }
    allowed_file_dct={}
    if opt.debug:
        opt.debug.write('\n------------------------------\nBlacklist Processing:\n')
        
    for filename in sorted(file_dct):
        please_blacklist=None
        #if (filename not in blacklist_dct) and ( os.path.dirname(filename) not in blacklist_dct ):
            # file or its dir is not blacklisted, return the filename
        #    allowed_file_dct[filename]=''
            #comment=blacklist_dct.get(filename,None)
            #if not comment:
            #    comment=blacklist_dct.get(os.path.dirname(filename),'None')
        for blacklist_name in sorted(blacklist_dct):
            #check for longest match available in blacklist name.
            #e.g. if a dir is blacklisted, block all files in it
            if opt.debug:
                opt.debug.write('searching: blacklist item {0}  in {1}\n'.format(blacklist_name, filename))
            if ( re.search( '^'+blacklist_name, filename)):
                if opt.debug:
                    opt.debug.write('{0} Matches Blacklist, ignoring\n'.format(blacklist_name))
                please_blacklist=True  
                break
            
        if not please_blacklist:
            allowed_file_dct[filename]=''

    return allowed_file_dct    


def check_whitelist(file_dct):
    # The whitelist is only checked on files that were added since the binary was installed
    # Unlike the Blacklist, the Whitelist must match all the way to the last directory name
    # or the exact file name.

    # If in the future, this doesn't make sense, it can be reverted to match blacklist behavior

    # For more detailed information refer to this User Guide document:
    #https://docs.cumulusnetworks.com/display/DOCS/Troubleshooting+the+etc+Directory

    # White list directories should not contain a trailing slash
    whitelist_dct={
        '/etc/apt': 'apt-get configuration file directory',
        '/etc/apt/sources.list.d': 'apt-get sources directory',
        '/etc/cumulus/.license' : 'Post 2.5.2 license file',
        '/etc/cumulus/.license.txt' : 'Pre-2.5.2 license file',
        '/etc/cumulus/ports.conf' : 'Front-panel interface definition',
        '/etc/cumulus/acl/policy.d': 'cl-acltool policies modified by user',
        '/etc/cumulus/ssmonitor.d': 'jdoo config files for daemon monitoring',
        '/etc/default/isc-dhcp-relay' : 'DHCP relay config file',
        '/etc/hostname' : 'Hostname file.  May be set manually here or via DHCP',
        '/etc/hosts' : 'Static list of host to ip address mapping',
        '/etc/motd' : 'Message of the day',
        '/etc/nsswitch.conf' : '',
        '/etc/network': 'All the config for the switch interfaces',
        '/etc/passwd' : 'System password file',
        '/etc/ptm.d': 'PTM daemon topology files',
        '/etc/quagga' : 'Quagga config files',
        '/etc/resolv.conf': 'DNS Resolver config.  Only include if modified and not using DHCP on eth0',
        '/etc/shadow' : 'System password file',
        '/etc/ssh' : 'ssh config files',
        '/etc/sysctl.d' : 'sysctl control options',
        '/etc/slotsync.conf': 'control file to copy config files to alt slot. Created by this script',
        '/home' : 'home directories for users',
        '/root' : 'root user home directory'
    }

    whitelisted_file_dct={}
    if opt.debug:
        opt.debug.write('\n------------------------------\nWhitelist Processing:\n')

    for filename in file_dct:
        comment=None
        if (filename.rstrip('/') in whitelist_dct) or ( os.path.dirname(filename).rstrip('/') in whitelist_dct ):
            # file or its dir is whitelisted, return a comment
            if opt.debug:
                opt.debug.write('Whitelisting: {0}\n'.format(filename))

            comment=whitelist_dct.get(filename,None)
            if not comment:
                comment=whitelist_dct.get(os.path.dirname(filename).rstrip('/'),None)

            whitelisted_file_dct[filename]=comment
        else:
            whitelisted_file_dct[filename]='File added/changed by admin or 3rd party app'
    
    return whitelisted_file_dct


def check_exclude_list(file_dct):
    allowed_file_dct={}
        
    # The exclude list attempts a longest match.  e.g. if you add '/etc' to this list,
    #  the entire /etc dir would be excluded (i.e. don't do that)
    if opt.debug:
        opt.debug.write('\n------------------------------\nExclude List Processing:\n')

    for filename in sorted(file_dct):
        please_exclude=None
        for exclude_name in sorted(opt.exclude_list):
            #check for longest match available in blacklist name.
            #e.g. if a dir is blacklisted, block all files in it
            if opt.debug:
                opt.debug.write('searching: Exclude list item {0}  in {1}\n'.format(exclude_name.strip().rstrip('/'), filename))
            if ( re.search( exclude_name.strip().rstrip('/'), filename)):
                if opt.debug:
                    opt.debug.write('{0} Matches Exclude list. Ignoring\n'.format(exclude_name.strip().rstrip('/')))
                please_exclude=True  
                break
            
        if not please_exclude:
            allowed_file_dct[filename]=''

    return allowed_file_dct    
    

def files_to_determine():
    #These files need to be determined if they should be on whitelist, blacklist or neither
    '''
    /etc/sysctl.d/*
    /etc/watchdog.d/*
    /etc/bash_completion.d/*  (git, vxfldcommon, vxrdctl)
    '''
    

def get_ppc_files():
    install_list_dct={}
    local_list_raw=''
    install_list_pattern=re.compile(r'''(?P<permissions>[rwxsStT-]+)
                                    \s+(?P<link_count>[0-9]+)
                                    \s+(?P<owner>\w+)
                                    \s+(?P<group>\w+)
                                    \s+(?P<size>\d+)
                                    \s+(?P<date>[0-9\-]+)
                                    \s+(?P<time>[0-9:]+)
                                    \.(?P<msec>[0-9]+)
                                    \s+(?P<timezone>[\+\-0-9]+)
                                    \s+
                                    '''+'/mnt/root\-ro(?P<filename>\S+)', re.X)
        
    # Get active slot
    #active => slot 2 (alt    ): 2.5.2-727a0c6-201504132128-build
    # or
    #active => slot 1 (primary): 2.5.5-4cd66d9-201512071810-build

    slot_pattern=re.compile('active\s+\=\>\s+slot\s+(?P<slot>[12]+)')
    cl_img_select=subprocess.check_output('cl-img-select')
    match=slot_pattern.search(cl_img_select)
    if match:
        slot='config{}'.format(match.group('slot'))
        # find all files in /etc /home /root in locally installed files and store
        # Note that links are not supported and will have to be recreated manually on the other side if needed
        #find /etc /home /root -type f -exec ls -l --full-time {} \;
        for dirname in ['etc', 'home', 'root']:
            try:
        
                local_list_raw=local_list_raw + subprocess.check_output(['find',
                                                '/mnt/root-rw/{0}/{1}'.format(slot, dirname),
                                                '-type', 'f',
                                                '-exec', 'ls', '-la', '--full-time', '{}', ';'])
            except subprocess.CalledProcessError as e:
                # dir didn't exist, just skip
                #print(e.output)
                pass
            
        
        install_list_raw=subprocess.check_output(['find',
                                                '/mnt/root-ro/etc',
                                                '/mnt/root-ro/home',
                                                '/mnt/root-ro/root',
                                                '-type', 'f',
                                                '-exec', 'ls', '-l', '--full-time', '{}', ';'])
        
       
        #Output sample:
        #-rw-r--r-- 1 root root 580 2016-02-03 18:48:58.752711375 +0000 /etc/network/interfaces
        
        
        for install_line in install_list_raw.split('\n'):
            match=install_list_pattern.match(install_line)
            if match:
                install_filename=match.group('filename')
                install_datetime='{} {}'.format(match.group('date'), match.group('time'))
                install_size=match.group('size')
                install_list_dct[install_filename]={ 'size': install_size, 'datetime' : install_datetime }
 
    else:
        print('Error: Could not match active slot in cl-img-select')
        sys.exit(1)
        
        
    #End get_ppc_files()     
    return install_list_dct, local_list_raw, slot


def get_x86_files():

    install_list_dct={}    
    installer_file='/var/lib/cumulus/installer/onie-installer'

    #Setup Regex's to parse the tar output
    #File sample:
    #-rw-r--r-- 105/107         111 2015-10-10 02:36:51 ./etc/quagga/bgpd.conf
    install_file_pattern=re.compile(r'''(?P<permissions>\-[rwxsStT-]+)
                                    \s+(?P<owner>\w+)
                                    /(?P<group>\w+)
                                    \s+(?P<size>\d+)
                                    \s+(?P<date>[0-9\-]+)
                                    \s+(?P<time>[0-9:]+)
                                    \s+\.(?P<filename>\S+)
                                    ''', re.X)
    
    # link sample
    #lrwxrwxrwx 0/0               0 2015-12-08 02:12:16 ./etc/alternatives/rlogin.1.gz -> /usr/share/man/man1/slogin.1.gz
    install_link_pattern=re.compile('^l')
    
    #directory sample
    #drwxr-xr-x 0/0               0 2015-02-22 11:38:03 ./etc/ld.so.conf.d/
    install_dir_pattern=re.compile('^d')
    
    #blank line
    install_blank_pattern=re.compile('^\W*$')
 
 
    # untar sysroot partition file data and store
    #Note, use import shlex; command_line= raw_input(); args=shlex.split(command_line) to sort out subprocess args
    
    tmp_dir=subprocess.check_output(['mktemp',  '-d']).rstrip('\n')
    print('temp dir created is {0}'.format(tmp_dir))
    print('\nExtracting initial install file\n')
    subprocess.call(['sh', installer_file, 'extract', tmp_dir])
    # This doesn't work, but we may not care...
    #subprocess.call(['cd', tmp_dir])
    
    # Actual command line to get the list of files out of the tar:
    '''
    tar -t -v --exclude=bin --exclude=boot --exclude=usr --exclude=sbin --exclude=dev --exclude=run --exclude=var
       --exclude=lib --full-time -f sysroot-release.tar.gz | egrep -v -- '^d|->'
    '''
    print('\nProcessing install archive\n')
    install_list_raw=subprocess.check_output(['tar', '-t', '-v',
                                             '--exclude=bin',
                                             '--exclude=boot',
                                             '--exclude=usr',
                                             '--exclude=sbin',
                                             '--exclude=dev',
                                             '--exclude=run',
                                             '--exclude=var',
                                             '--exclude=lib',
                                             '--full-time',
                                             '-f', 'sysroot-release.tar.gz'],
                                             cwd=tmp_dir)
    
           
    #Remove tmp_dir here to save space in case of crash
    print('Deleting temp dir {0}\n'.format(tmp_dir))
    shutil.rmtree(tmp_dir)
    
    
    for install_line in install_list_raw.split('\n'):
        #if opt.debug:
        #    opt.debug.write('Processing install line {}\n'.format(install_line))
            
        match=install_file_pattern.match(install_line)
        if match:
            install_filename=match.group('filename')
            install_datetime='{} {}'.format(match.group('date'), match.group('time'))
            install_size=match.group('size')
            install_list_dct[install_filename]={ 'size': install_size, 'datetime' : install_datetime }
            
        elif install_link_pattern.match(install_line):
            # This is a link.  Put in a separate list to check later
            pass
        
        elif install_dir_pattern.match(install_line):
            # This is a directory. ignore
            pass
            
        elif install_blank_pattern.match(install_line):
            #Blank line. Ignore
            pass
    
        else:
            # No match
            print('Error: Installed image filename, date, and size not parsed correctly.')
            print('Line: #'+install_line+'#')
            print('Decide what to do here... exit or continue')
            
    if opt.debug:
        opt.debug.write('--------------------------\ninstall_list_dct:\n')
        opt.debug.write(pformat(install_list_dct))
    
    # find all files in /etc /home /root in locally installed files and store
    local_list_raw=subprocess.check_output(['find',
                                            '/etc',
                                            '/home',
                                            '/root',
                                            '-type', 'f',
                                            '-exec', 'ls', '-l', '--full-time', '{}', ';'])
    #Output sample:
    #-rw-r--r-- 1 root root 580 2016-02-03 18:48:58.752711375 +0000 /etc/network/interfaces
    
    # End get_x86_files()
    return install_list_dct, local_list_raw


def create_slotsync_conf(added_file_dct, changed_file_dct):
    slotsync_fn='/etc/slotsync.conf'
    upgrade_script_fn='2x_upgrade_script'
    prev_slotsync='/etc/slotsync.bak'
    # backup the previous slotsync file if exists
    if os.path.exists(slotsync_fn):
        os.rename(slotsync_fn, prev_slotsync)
        
    slotsync_file=open(slotsync_fn, 'w')
    
    slotsync_file.write('## ' + slotsync_fn + '\n')
    slotsync_file.write('''
####################################################################
## Configuration file for ''' + upgrade_script_fn + '''
##
## A list of files and directories, one per line.
## Directories are copied recursively.
## To explicitly exclude a file or directory, start a line with '-'.
## Comments start with #. Uncomment examples below to enable them.
####################################################################

''')
    
    slotsync_file.write('# Files Added since install\n')
    for added_file in sorted(added_file_dct):
        slotsync_file.write('{0}\n'.format(added_file))
        
    slotsync_file.write('\n')
    slotsync_file.write('# Files Changed since install\n')
    for changed_file in sorted(changed_file_dct):
        slotsync_file.write('{0}\n'.format(changed_file))
        
    slotsync_file.close()
    print('\n' + slotsync_fn + ' created.')
    
        
def create_backup_tar(added_file_dct, changed_file_dct):
    #mktemp dir
    tmp_dir=subprocess.check_output(['mktemp',  '-d']).rstrip('\n')
    datestamp=time.strftime("%Y-%m-%d-%H:%M:%S")
    tarfilename=os.path.join(tmp_dir, 'config-archive-' + datestamp +'.tar')
    print('\nCreating Config archive: ' + tarfilename)

    # 
    #copy files to temp_dir?  or just add file to tar
    #Either of these methods would work:
    #for file in list:
    #  cp --parents {file} {tmp_dir}/
    #tar cv -f {tmp_dir}/foo.tar -C tmp_dir  etc/network/interfaces
    #
    #  or  (this one thrashes the disk less)
    #for file in list:
    #  tar rv -f {tmp_dir}/foo.tar filename
    
    
    # Add all the files to the tarfilename
    print('Adding to config archive:  Files Added since initial install')
    for filename in added_file_dct:
        #copy to tmp_dir
        subprocess.call(['tar', '-r', '-P', '-f', tarfilename, filename])
    
    print('Adding to config archive:  Files Changed since initial install')
    for filename in changed_file_dct:
        subprocess.call(['tar', '-r', '-P', '-f', tarfilename , filename])


    #Now compress it
    print('Compressing tarfile to {0}.gz'.format(tarfilename))
    subprocess.call(['gzip', tarfilename])
    tarfilename='{0}.gz'.format(tarfilename)
    
    
    #Do I want to specify a location for the file?  could be /mnt/persist/backup-configs, could be /tmp, could be /etc
    # Make the backup_dir if is doesn't exist
    if not os.path.exists(opt.backup_dir):
        os.makedirs(opt.backup_dir)

    # need to check space
    print('Checking space on {0}'.format(opt.backup_dir))
    statvfs=os.statvfs(opt.backup_dir)
    free=statvfs.f_frsize * statvfs.f_bfree
    tarfileinfo=os.stat(tarfilename)
    if tarfileinfo.st_size > free:
        print('Error: {0} filesystem does not have enough free space to store tar file'.format(opt.backup_dir))
        print('Free space: {0} {1} size: {2}'.format(free, tarfilename, tarfileinfo.st_size))
        sys.exit(1)

    # Copy the tarfile to the backup_dir
    print('Copying tarfile to {0}/{1}'.format(opt.backup_dir, tarfilename))
    shutil.copy(tarfilename, opt.backup_dir)
    
    print('Removing temp dir {0}'.format(tmp_dir))
    shutil.rmtree(tmp_dir)
    

def run_slotsync_script():
    
    yes_list = ["y", "Y"]
    
    if not opt.force:
        #Verify user wants to run slotsync via Y/n input
        py3 = version_info[0] > 2 #creates boolean value for test that Python major version > 2
        if py3:
            response = input("Do you wish to sync these files to the alternate slot now? (Y/n):")
        else:
            response = raw_input("Do you wish to sync these files to the alternate slot now? (Y/n): ")
        
        if response.strip():
            if response.lstrip()[0] not in yes_list:
                print("Files will not be synced to the alternate slot")
                return
    #
    print('\nCalling ' + opt.slotsync_script + '  to copy config files to alternate slot\n')
    subprocess.call(opt.slotsync_script)


def fixup_lldp_quagga():
    pass
    # look in cl-img-install -u code for files to run on first boot and put this there...
    #sudo chown _lldpd /usr/bin/lldpcli
    #sudo service restart
    #sudo chown quagga:quagga /var/log/quagga
    
    
def check_if_root_or_sudo():
    pass

def usage():
    
    print("Usage: " + sys.argv[0] + '[-b] [-d backupdirname] [-n] [-q] [-s] [-f] [-v] [-x] [-h]')
    print "\nDetermine changed config files. Optionally create backup archive or sync to other slot\n"
    print "{0:<15}: {1}".format(" no args", "Default: Print output of changed config files to screen")
    print "{0:<15}: {1}".format("-b, --backup", "Create a backup archive of changed config files. ")
    print "{0:<15}: {1}".format("-c, --create", "Create /etc/slotsync.conf - but don't call slotsync")
    print "{0:<15}: {1}".format("-d, --backup_dir [dir]", "Location to store backup archive. Default dir is /mnt/persist/backup")
    print "{0:<15}: {1}".format("-n, --dryrun", "Output to screen but don't create any files")
    print "{0:<15}: {1}".format("-q, --quiet", "No output to screen, only create any files requested ")    
    print "{0:<15}: {1}".format("-s, --sync", "Create /etc/slotsync.conf file and call slotsync to move file to alternate slot")
    print "{0:<15}: {1}".format("-f, --force", "Used with -s. Do not ask before running slotsync and moving files")
    print "{0:<15}: {1}".format("-v, --debug", "Verbose: Write out debugging logs to /etc/upgrade-tool-debug.log ")    
    print "{0:<15}: {1}".format("-x, --exclude dirs", "Exclude a comma separated list of dirs: e.g.  -x /root,/home")
    print "{0:<15}: {1}".format("-h, --help", "Show this message")


def parse_opts():

    try:
        opts, args = getopt.getopt(sys.argv[1:],"hbdfnqsvx:",["help", "backup", "backup_dir=",
                                                      "debug", "force", "dryrun",
                                                      "quiet", "sync", "exclude="])
    except getopt.GetoptError:
        usage()
        sys.exit(2)
    for opt_arg, arg in opts:
        if opt_arg in ('-h', '--help'):
            usage()
            sys.exit()
        elif opt_arg in ("-b", "--backup"):
            opt.backup=True
        elif opt_arg in ("-c", "--create"):
            opt.create=True
        elif opt_arg in ("-d", "--backup_dir"):
            opt.backup_dir=arg
        elif opt_arg in ("-v", "--debug"):
            opt.debug=open(opt.debug_fn, 'w')
        elif opt_arg in ("-f", "--force"):
            opt.force=True 
        elif opt_arg in ("-n", "--dryrun"):
            opt.dryrun=True
        elif opt_arg in ("-q", "--quiet"):
            opt.quiet=True
        elif opt_arg in ("-s", "--sync"):
            opt.create=True
            opt.sync=True
        elif opt_arg in ("-x", "--exclude"):
            #print('Exclude arg is {}'.format(arg))
            opt.exclude_list=arg.split(',')
            #print('Exclude list is {0}'.format(exclude_list))
        else:
            print("Bug: Unhandled option")
            sys.exit(1)

    if opt.debug and not opt.quiet:
        print('Created debug log file {0}'.format(opt.debug_fn))
    

def main():
    
    check_if_root_or_sudo()
    
    parse_opts()
        
    # setup variables - debug(store data in local files), string lists
    install_list_dct={}
    local_list_dct={}
    added_file_dct={}
    changed_file_dct={}
    deleted_file_dct={}
    tmp_dir=None
    blank_line_pattern=re.compile('^\W*$')

    # Collect all the file data:
    # find and extract install file based on arch in uname -a
    arch=subprocess.check_output(['uname', '-m']).rstrip('\n')
    
    if arch == "ppc":
        install_list_dct, local_list_raw, slot = get_ppc_files()
        local_list_pattern=re.compile(r'''(?P<permissions>[rwxsStT-]+)
                                    \s+(?P<link_count>[0-9]+)
                                    \s+(?P<owner>\w+)
                                    \s+(?P<group>\w+)
                                    \s+(?P<size>\d+)
                                    \s+(?P<date>[0-9\-]+)
                                    \s+(?P<time>[0-9:]+)
                                    \.(?P<msec>[0-9]+)
                                    \s+(?P<timezone>[\+\-0-9]+)
                                    \s+
                                    '''+'/mnt/root\-rw/'+slot+'(?P<filename>\S+)', re.X)
       
       
    if arch == 'arm':
        #TBD - probably will look like x86
        pass
     
    
    if arch == 'x86_64':
        install_list_dct, local_list_raw = get_x86_files()
        local_list_pattern=re.compile(r'''(?P<permissions>[rwxsStT-]+)
                                      \s+(?P<link_count>[0-9]+)
                                      \s+(?P<owner>\w+)
                                      \s+(?P<group>\w+)
                                      \s+(?P<size>\d+)
                                      \s+(?P<date>[0-9\-]+)
                                      \s+(?P<time>[0-9:]+)
                                      \.(?P<msec>[0-9]+)
                                      \s+(?P<timezone>[\+\-0-9]+)
                                      \s+(?P<filename>\S+)
                                      ''', re.X)
      
    
    
    # Loop through all local files and determine adds, changes, deletes. 
    for local_line in local_list_raw.split('\n'):
        comment=None
        match=local_list_pattern.match(local_line)
        if match:
            local_filename=match.group('filename')
            local_datetime='{} {}'.format(match.group('date'), match.group('time'))
            local_size=match.group('size')
            local_list_dct[local_filename]={ 'size': local_size, 'datetime' : local_datetime }
            if local_filename in install_list_dct:
                #File exists in both places.  Check to see if it has been modified
                install_datetime=install_list_dct[local_filename]['datetime']
                install_size=install_list_dct[local_filename]['size']
                if ( local_size != install_size) or ( local_datetime != install_datetime):
                    #File has been changed
                    changed_file_dct[local_filename]=''
     
            else:
                #local file not installed by installer, it is an added file
                added_file_dct[local_filename]=''

        elif blank_line_pattern.match(local_line):
            #Blank line. Ignore
            pass
        
        else:
            print('Error: Local filename, date, and size not parsed correctly.')
            print('Local Line: #'+local_line+'#')
            print('Decide what to do here... exit or continue')
     
    if opt.debug:
        opt.debug.write('\n------------------------------\nTemp added file list:\n')
        opt.debug.write(pformat(added_file_dct))
        opt.debug.write('\n------------------------------\nTemp changed file list:\n')
        opt.debug.write(pformat(changed_file_dct))
    
    # Cannot determine this on ppc, so only check x86
    # Loop through installed files and flag any files that have been deleted
    # This may be a pointless exercise and probably can be safely removed
    if arch=='x86_64':
        for install_filename in sorted(install_list_dct):
            if install_filename not in local_list_dct:
                deleted_file_dct[install_filename]="Note: File has been deleted since original binary install"
     
    
    # Loop through adds and compare to blacklist, whitelist.  Mark others as 3rd party
    added_file_dct=check_blacklist(added_file_dct)
    added_file_dct=check_exclude_list(added_file_dct)
    added_file_dct=check_whitelist(added_file_dct)
    
    # Loop through changes and compare to blacklist
    changed_file_dct=check_blacklist(changed_file_dct)
    changed_file_dct=check_exclude_list(changed_file_dct)
    # The only reason to check changed files against whitelist is to mark them with comments.
    # if they were changed and not blacklisted, they are important
    changed_file_dct=check_whitelist(changed_file_dct)
    
    
    # Loop through deletes and compare to blacklist, whitelist
    # No need at this time
    
    # output results to screen and a slotsync.conf file
    if not opt.quiet:
        print('Files Added since initial install:')
        for filename in sorted(added_file_dct):
            print('{0:<40}{1:<10} # {2}'.format(filename, local_list_dct[filename]['datetime'], added_file_dct[filename]))

        print('')
        print('Files Changed since initial install:')
        for filename in sorted(changed_file_dct):
            print('{0:<40}{1:<10} # {2}'.format(filename, local_list_dct[filename]['datetime'], changed_file_dct[filename]))
           
        if arch=='x86_64':    
            print('')
            print('Files Deleted since initial install:')
            for filename in sorted(deleted_file_dct):
                print('{0:<40}# {1}'.format(filename, deleted_file_dct[filename]))

    if opt.create and not opt.dryrun:
        create_slotsync_conf(added_file_dct, changed_file_dct)
        
    if opt.backup and not opt.dryrun:
        create_backup_tar(added_file_dct, changed_file_dct)

    if opt.debug:
        opt.debug.close()

    if opt.sync and not opt.dryrun:
        run_slotsync_script()
        
    fixup_lldp_quagga()
    

if __name__ == '__main__':
    main()
    