#!/usr/bin/env python

import sys, getopt
import subprocess
import re
import os
import time
import shutil
import shlex
from pprint import pprint 
from pprint import pformat
from sys import version_info


#To do's
# 14) Refactor slotsync into this script using python
# 5) Package into deb with slotsync - upgrade-tools  (Ben)
# 10) Write readme.md file for repo with examples
# 11) Rename, and set log file to match new name
# 12) implement and test arch=arm
# 13) refactor debugging and print to use log facility


#X 1) implement arg processing
#X 2) backup archive option
#X 3) Create slotsync file
#X 6) Exclude dir list implementation
#X 8) Refactor main into 1-2 smaller functions
#X 9) refactor main again - separate parse_opts
#X 4) Call slotsync script
#X 7) Check if root or sudo and warn/exit if not


class opt(object):
    force=False
    backup=False
    #backup_dir default could be /mnt/persist/backup-configs, could be /tmp, could be /etc
    backup_dir='/mnt/persist/backup'
    create=False
    debug_fn='/var/log/' + sys.argv[0] + '.log'
    debug=False
    sync=False
    dryrun=False
    quiet=False
    exclude_list=[]
    slotsync_script='./slotsync'
    slotsync_conf='/etc/slotsync.conf'
    slotsync_include='/tmp/include.XXXXXX'
    

def check_blacklist(file_dct):
    # For more detailed information refer to this User Guide document:
    #https://docs.cumulusnetworks.com/display/DOCS/Troubleshooting+the+etc+Directory
    
    # The Blacklist attempts a longest match.  e.g. if you add '/etc' to this list,
    #  the entire /etc dir would be excluded (i.e. don't do that)
    
    # Note that this script only support /etc/, /home/ and /root/ dirs
    #the following dirs are automatically excluded later in this script:
    # '/bin' : 'Executables that should be installed via apt.  Do not copy',
    # '/boot' : 'Low level boot init data. Do not copy',
    # '/dev' : 'Device table info. Do not copy',
    # '/lib' : 'Executable libraries should be installed via apt.  Do not copy',
    # '/proc' : 'Kernel data. Do not copy',
    # '/sbin' : 'System executables should be installed by OS or apt.  Do not copy',
    # '/sys' : 'Kernel data. Do not copy',
    # '/run' : 'Process data. Do not copy',
    # '/usr' : 'Executables and libraries should be installed by OS or apt.  Do not copy',
    # '/var' : 'Various data and libraries should be installed by OS or apt. Do not copy',
    # '/var/lib/apt' : 'Transient apt data. Do not copy',
    # '/var/lib/dpkg' : 'Transient dpkg data. Do not copy',
    # '/var/lib/cumulus' : 'Transient cumulus os data. Do not copy'


    # Blacklist directory names should not contain a trailing slash
    blacklist_dct={
        '/etc/adjtime': 'System clock adjustment data - let ntp manage, in case switch hardware is replaced',
        '/etc/bcm.d': 'Per platform hardware config dir, created on first boot.  Do not copy',
        '/etc/blkid.tab': 'Partition table - should not be modified manually. Do not copy',
        '/etc/blkid.tab.old': 'a previous partition table - should not be modified manually. Do not copy',
        '/etc/cumulus/init': 'Platform hardware specific files.  Do not copy',
        '/etc/default/clagd': 'Created and managed by ifupdown2. Do not copy',
        '/etc/default/grub': 'Grub init table should not be modified manually',
        '/etc/default/hwclock': 'Platform hardware specific file.  Created during first boot. Do not copy',
        '/etc/default/hwclock.ucf-dist': 'Old merge conflict file, see RN-301 in 2.5.3. Do not copy',
        '/etc/default/phy_ucode_update': 'Created during first boot.  Do not copy',
        '/etc/init': 'Platform initialization files. Do not copy',
        '/etc/init.d': 'Platform initialization files.  Do not copy',
        '/etc/fstab': 'Static info on filesystem. Do not copy',
        '/etc/lsb-release' : 'System version data.  Do not copy',
        '/etc/lvm/archive': 'Filesystem files.  Do not copy',
        '/etc/lvm/backup': 'Filesystem files. Do not copy',
        '/etc/modules': 'Created during first boot.  Do not copy',
        '/etc/os-release' : 'System version data. Do not copy',
        '/etc/sensors.d': 'Platform specific sensor data. Created during first boot. Do not copy',
        '/root/.ansible': 'Ansible tmp files. Do not copy.',
        '/home/cumulus/.ansible': 'Ansible tmp files. Do not copy'
    }
    
    allowed_file_dct={}
    if opt.debug:
        opt.debug.write('\n------------------------------\nBlacklist Processing:\n')
        
    for filename in sorted(file_dct):
        please_blacklist=None
        #if (filename not in blacklist_dct) and ( os.path.dirname(filename) not in blacklist_dct ):
            # file or its dir is not blacklisted, return the filename
        #    allowed_file_dct[filename]=''
            #comment=blacklist_dct.get(filename,None)
            #if not comment:
            #    comment=blacklist_dct.get(os.path.dirname(filename),'None')
        for blacklist_name in sorted(blacklist_dct):
            #check for longest match available in blacklist name.
            #e.g. if a dir is blacklisted, block all files in it
            if opt.debug:
                opt.debug.write('searching: blacklist item {0}  in {1}\n'.format(blacklist_name, filename))
            if ( re.search( '^'+blacklist_name, filename)):
                if opt.debug:
                    opt.debug.write('{0} Matches Blacklist, ignoring\n'.format(blacklist_name))
                please_blacklist=True  
                break
            
        if not please_blacklist:
            allowed_file_dct[filename]=''

    return allowed_file_dct    


def check_whitelist(file_dct):
    # The whitelist is only checked on files that were added since the binary was installed
    # Unlike the Blacklist, the Whitelist must match all the way to the last directory name
    # or the exact file name.

    # If in the future, this doesn't make sense, it can be reverted to match blacklist behavior

    # For more detailed information refer to this User Guide document:
    #https://docs.cumulusnetworks.com/display/DOCS/Troubleshooting+the+etc+Directory

    # White list directories should not contain a trailing slash
    whitelist_dct={
        '/etc/apt': 'apt-get configuration file directory',
        '/etc/apt/sources.list.d': 'apt-get sources directory',
        '/etc/cumulus/.license' : 'Post 2.5.2 license file',
        '/etc/cumulus/.license.txt' : 'Pre-2.5.2 license file',
        '/etc/cumulus/ports.conf' : 'Front-panel interface definition',
        '/etc/cumulus/acl/policy.d': 'cl-acltool policies modified by user',
        '/etc/cumulus/ssmonitor.d': 'jdoo config files for daemon monitoring',
        '/etc/default/isc-dhcp-relay' : 'DHCP relay config file',
        '/etc/hostname' : 'Hostname file.  May be set manually here or via DHCP',
        '/etc/hosts' : 'Static list of host to ip address mapping',
        '/etc/motd' : 'Message of the day',
        '/etc/nsswitch.conf' : '',
        '/etc/network': 'All the config for the switch interfaces',
        '/etc/passwd' : 'System password file',
        '/etc/ptm.d': 'PTM daemon topology files',
        '/etc/quagga' : 'Quagga config files',
        '/etc/resolv.conf': 'DNS Resolver config.  Only include if modified and not using DHCP on eth0',
        '/etc/shadow' : 'System password file',
        '/etc/ssh' : 'ssh config files',
        '/etc/sysctl.d' : 'sysctl control options',
        '/etc/slotsync.bak':'previous copy of slotsync.conf.  Created by this script',
        '/etc/slotsync.conf': 'control file to copy config files to alt slot. Created by this script',
        '/home' : 'home directories for users',
        '/root' : 'root user home directory'
    }

    whitelisted_file_dct={}
    if opt.debug:
        opt.debug.write('\n------------------------------\nWhitelist Processing:\n')

    for filename in file_dct:
        comment=None
        if (filename.rstrip('/') in whitelist_dct) or ( os.path.dirname(filename).rstrip('/') in whitelist_dct ):
            # file or its dir is whitelisted, return a comment
            if opt.debug:
                opt.debug.write('Whitelisting: {0}\n'.format(filename))

            comment=whitelist_dct.get(filename,None)
            if not comment:
                comment=whitelist_dct.get(os.path.dirname(filename).rstrip('/'),None)

            whitelisted_file_dct[filename]=comment
        else:
            whitelisted_file_dct[filename]='File added/changed by admin or 3rd party app'
    
    return whitelisted_file_dct


def check_exclude_list(file_dct):
    allowed_file_dct={}
        
    # The exclude list attempts a longest match.  e.g. if you add '/etc' to this list,
    #  the entire /etc dir would be excluded (i.e. don't do that)
    if opt.debug:
        opt.debug.write('\n------------------------------\nExclude List Processing:\n')

    for filename in sorted(file_dct):
        please_exclude=None
        for exclude_name in sorted(opt.exclude_list):
            #check for longest match available in blacklist name.
            #e.g. if a dir is blacklisted, block all files in it
            if opt.debug:
                opt.debug.write('searching: Exclude list item {0}  in {1}\n'.format(exclude_name.strip().rstrip('/'), filename))
            if ( re.search( exclude_name.strip().rstrip('/'), filename)):
                if opt.debug:
                    opt.debug.write('{0} Matches Exclude list. Ignoring\n'.format(exclude_name.strip().rstrip('/')))
                please_exclude=True  
                break
            
        if not please_exclude:
            allowed_file_dct[filename]=''

    return allowed_file_dct    
    

def files_to_determine():
    #These files need to be determined if they should be on whitelist, blacklist or neither
    '''
    /etc/sysctl.d/*
    /etc/watchdog.d/*
    /etc/bash_completion.d/*  (git, vxfldcommon, vxrdctl)
    '''

    
def clean_mnt_persist():
    # If there are files in mnt/persist, then running this script may be to no avail
    # so we need to clean out al files in /mnt/persist except license files
    # and /mnt/persist/backup/ since we are storing archive files there
    yes_list = ["y", "Y"]
    
    # Need to create logging here for when run via ansible with --force option
    print('Any stale files in /mnt/persist/ will overwrite files in the new slot on boot-up')
    print('Only license files and backup config archives should be stored in /mnt/persist')
    print('Auto-cleaning old /etc files out of /mnt/persist to avoid upgrade hangovers')
    print('Only license files and backup archive files will be preserved.')
    print('The following files, and any empty directories will be deleted:')
    print('')
    sys.stdout.flush()
    
    subprocess.call(['find', '/mnt/persist/', '-depth',
                     '-path', '/mnt/persist/etc/cumulus/.license*',
                     '-o', '-path', '/mnt/persist/backup/*',
                     '-o', '!', '-type', 'd', '-print',
                     '-o', '-type', 'd', '-empty', '-print'])
    
    if not opt.force:
        py3 = version_info[0] > 2 #creates boolean value for test that Python major version > 2
        if py3:
            response = input("Do you wish to continue and delete these files? (Y/n):")
        else:
            response = raw_input("Do you wish to continue and delete these files? (Y/n): ")
        
        if response.strip():
            if response.lstrip()[0] not in yes_list:
                print("Files in /mnt/persist not removed.  Proceed with caution")
                return
    
    # -depth - list dirs after files contained in them
    # this is used at end of recipe to delete the empty dirs after files in them are removed
    # ignore license files and the files in the backup dir
    # ignore directories (only list files) and delete all files not ignored previously
    # then go back and delete any empty dirs after removing files (see -depth)
    
    subprocess.call(['find', '/mnt/persist/', '-depth',
                     '-path', '/mnt/persist/etc/cumulus/.license*',
                     '-o', '-path', '/mnt/persist/backup/*',
                     '-o', '!', '-type', 'd', '-delete',
                     '-o', '-type', 'd', '-empty', '-delete'])


def get_slots():
    # Get active slot
    #active => slot 2 (alt    ): 2.5.2-727a0c6-201504132128-build
    # or
    #active => slot 1 (primary): 2.5.5-4cd66d9-201512071810-build

    slot_pattern=re.compile('active\s+\=\>\s+slot\s+(?P<active_slot>[12]+)')
    cl_img_select=subprocess.check_output('cl-img-select')
    match=slot_pattern.search(cl_img_select)
    if match:
        active_slot=match.group('active_slot')
        slots=['1', '2']
        slots.remove(active_slot)
        inactive_slot=slots[0]
        return active_slot, inactive_slot
    else:
        print('Error: Could not match active slot in cl-img-select')
        sys.exit(1)
        

def get_ppc_files(active_slot):
    install_list_dct={}
    local_list_raw=''
    install_list_pattern=re.compile(r'''(?P<permissions>[rwxsStT-]+)
                                    \s+(?P<link_count>[0-9]+)
                                    \s+(?P<owner>\w+)
                                    \s+(?P<group>\w+)
                                    \s+(?P<size>\d+)
                                    \s+(?P<date>[0-9\-]+)
                                    \s+(?P<time>[0-9:]+)
                                    \.(?P<msec>[0-9]+)
                                    \s+(?P<timezone>[\+\-0-9]+)
                                    \s+
                                    '''+'/mnt/root\-ro(?P<filename>\S+)', re.X)
    
    slot='config{}'.format(active_slot)
    # find all files in /etc /home /root in locally installed files and store
    # Note that links are not supported and will have to be recreated manually on the other side if needed
    #find /etc /home /root -type f -exec ls -l --full-time {} \;
    for dirname in ['etc', 'home', 'root']:
        try:
    
            local_list_raw=local_list_raw + subprocess.check_output(['find',
                                            '/mnt/root-rw/{0}/{1}'.format(slot, dirname),
                                            '-type', 'f',
                                            '-exec', 'ls', '-la', '--full-time', '{}', ';'])
        except subprocess.CalledProcessError as e:
            # dir didn't exist, just skip
            #print(e.output)
            pass
        
    
    install_list_raw=subprocess.check_output(['find',
                                            '/mnt/root-ro/etc',
                                            '/mnt/root-ro/home',
                                            '/mnt/root-ro/root',
                                            '-type', 'f',
                                            '-exec', 'ls', '-l', '--full-time', '{}', ';'])
    
   
    #Output sample:
    #-rw-r--r-- 1 root root 580 2016-02-03 18:48:58.752711375 +0000 /etc/network/interfaces
    
    
    for install_line in install_list_raw.split('\n'):
        match=install_list_pattern.match(install_line)
        if match:
            install_filename=match.group('filename')
            install_datetime='{} {}'.format(match.group('date'), match.group('time'))
            install_size=match.group('size')
            install_list_dct[install_filename]={ 'size': install_size, 'datetime' : install_datetime }
 
        
    #End get_ppc_files()     
    return install_list_dct, local_list_raw


def get_x86_files():

    install_list_dct={}    
    installer_file='/var/lib/cumulus/installer/onie-installer'

    #Setup Regex's to parse the tar output
    #File sample:
    #-rw-r--r-- 105/107         111 2015-10-10 02:36:51 ./etc/quagga/bgpd.conf
    install_file_pattern=re.compile(r'''(?P<permissions>\-[rwxsStT-]+)
                                    \s+(?P<owner>\w+)
                                    /(?P<group>\w+)
                                    \s+(?P<size>\d+)
                                    \s+(?P<date>[0-9\-]+)
                                    \s+(?P<time>[0-9:]+)
                                    \s+\.(?P<filename>\S+)
                                    ''', re.X)
    
    # link sample
    #lrwxrwxrwx 0/0               0 2015-12-08 02:12:16 ./etc/alternatives/rlogin.1.gz -> /usr/share/man/man1/slogin.1.gz
    install_link_pattern=re.compile('^l')
    
    #directory sample
    #drwxr-xr-x 0/0               0 2015-02-22 11:38:03 ./etc/ld.so.conf.d/
    install_dir_pattern=re.compile('^d')
    
    #blank line
    install_blank_pattern=re.compile('^\W*$')
 
 
    # untar sysroot partition file data and store
    #Note, use import shlex; command_line= raw_input(); args=shlex.split(command_line) to sort out subprocess args
    
    tmp_dir=subprocess.check_output(['mktemp',  '-d']).rstrip('\n')
    print('temp dir created is {0}'.format(tmp_dir))
    print('\nExtracting initial install file\n')
    subprocess.call(['sh', installer_file, 'extract', tmp_dir])
    # This doesn't work, but we may not care...
    #subprocess.call(['cd', tmp_dir])
    
    # Actual command line to get the list of files out of the tar:
    '''
    tar -t -v --exclude=bin --exclude=boot --exclude=usr --exclude=sbin --exclude=dev --exclude=run --exclude=var
       --exclude=lib --full-time -f sysroot-release.tar.gz | egrep -v -- '^d|->'
    '''
    print('\nProcessing install archive\n')
    install_list_raw=subprocess.check_output(['tar', '-t', '-v',
                                             '--exclude=bin',
                                             '--exclude=boot',
                                             '--exclude=usr',
                                             '--exclude=sbin',
                                             '--exclude=dev',
                                             '--exclude=run',
                                             '--exclude=var',
                                             '--exclude=lib',
                                             '--full-time',
                                             '-f', 'sysroot-release.tar.gz'],
                                             cwd=tmp_dir)
    
           
    #Remove tmp_dir here to save space in case of crash
    print('Deleting temp dir {0}\n'.format(tmp_dir))
    shutil.rmtree(tmp_dir)
    
    
    for install_line in install_list_raw.split('\n'):
        #if opt.debug:
        #    opt.debug.write('Processing install line {}\n'.format(install_line))
            
        match=install_file_pattern.match(install_line)
        if match:
            install_filename=match.group('filename')
            install_datetime='{} {}'.format(match.group('date'), match.group('time'))
            install_size=match.group('size')
            install_list_dct[install_filename]={ 'size': install_size, 'datetime' : install_datetime }
            
        elif install_link_pattern.match(install_line):
            # This is a link.  Put in a separate list to check later
            pass
        
        elif install_dir_pattern.match(install_line):
            # This is a directory. ignore
            pass
            
        elif install_blank_pattern.match(install_line):
            #Blank line. Ignore
            pass
    
        else:
            # No match
            print('Error: Installed image filename, date, and size not parsed correctly.')
            print('Line: #'+install_line+'#')
            print('Decide what to do here... exit or continue')
            
    if opt.debug:
        opt.debug.write('--------------------------\ninstall_list_dct:\n')
        opt.debug.write(pformat(install_list_dct))
    
    # find all files in /etc /home /root in locally installed files and store
    local_list_raw=subprocess.check_output(['find',
                                            '/etc',
                                            '/home',
                                            '/root',
                                            '-type', 'f',
                                            '-exec', 'ls', '-l', '--full-time', '{}', ';'])
    #Output sample:
    #-rw-r--r-- 1 root root 580 2016-02-03 18:48:58.752711375 +0000 /etc/network/interfaces
    
    # End get_x86_files()
    return install_list_dct, local_list_raw


def create_slotsync_conf(added_file_dct, changed_file_dct):
    prev_slotsync=opt.slotsync_conf.split('.')[0]+'.bak'
    # backup the previous slotsync file if exists
    if os.path.exists(opt.slotsync_conf):
        os.rename(opt.slotsync_conf, prev_slotsync)
        
    slotsync_file=open(opt.slotsync_conf, 'w')
    
    slotsync_file.write('## ' + opt.slotsync_conf + '\n')
    slotsync_file.write('''
####################################################################
## Configuration file for ''' + opt.slotsync_script + '''
##
## A list of files and directories, one per line.
## Directories are copied recursively.
## To explicitly exclude a file or directory, start a line with '-'.
## Comments start with #. Uncomment examples below to enable them.
####################################################################

''')
    
    slotsync_file.write('# Files Added since install\n')
    for added_file in sorted(added_file_dct):
        slotsync_file.write('{0}\n'.format(added_file))
        
    slotsync_file.write('\n')
    slotsync_file.write('# Files Changed since install\n')
    for changed_file in sorted(changed_file_dct):
        slotsync_file.write('{0}\n'.format(changed_file))
        
    slotsync_file.close()
    print('\n' + opt.slotsync_conf + ' created.')
    
        
def create_backup_tar(added_file_dct, changed_file_dct):
    #mktemp dir
    tmp_dir=subprocess.check_output(['mktemp',  '-d']).rstrip('\n')
    datestamp=time.strftime("%Y-%m-%d-%H:%M:%S")
    tarfilename=os.path.join(tmp_dir, 'config-archive-' + datestamp +'.tar')
    print('\nCreating Config archive: ' + tarfilename)

    # 
    #copy files to temp_dir?  or just add file to tar
    #Either of these methods would work:
    #for file in list:
    #  cp --parents {file} {tmp_dir}/
    #tar cv -f {tmp_dir}/foo.tar -C tmp_dir  etc/network/interfaces
    #
    #  or  (this one thrashes the disk less)
    #for file in list:
    #  tar rv -f {tmp_dir}/foo.tar filename
    
    ### pass
    ### This can be done with the tarfile library:
    ### import tarfile
    ### tar = tarfile.open("sample.tar.gz", "w:gz")
    ###    for name in ["foo", "bar", "quux"]:
    ###        tar.add(name)
    ###    tar.close()

    # Add all the files to the tarfilename
    print('Adding to config archive:  Files Added since initial install')
    for filename in added_file_dct:
        #copy to tmp_dir
        subprocess.call(['tar', '-r', '-P', '-f', tarfilename, filename])
    
    print('Adding to config archive:  Files Changed since initial install')
    for filename in changed_file_dct:
        subprocess.call(['tar', '-r', '-P', '-f', tarfilename , filename])


    #Now compress it
    print('Compressing tarfile to {0}.gz'.format(tarfilename))
    subprocess.call(['gzip', tarfilename])
    tarfilename='{0}.gz'.format(tarfilename)
    
    
    #Do I want to specify a location for the file?  could be /mnt/persist/backup-configs, could be /tmp, could be /etc
    # Make the backup_dir if is doesn't exist
    if not os.path.exists(opt.backup_dir):
        os.makedirs(opt.backup_dir)

    # need to check space
    print('Checking space on {0}'.format(opt.backup_dir))
    statvfs=os.statvfs(opt.backup_dir)
    free=statvfs.f_frsize * statvfs.f_bfree
    tarfileinfo=os.stat(tarfilename)
    if tarfileinfo.st_size > free:
        print('Error: {0} filesystem does not have enough free space to store tar file'.format(opt.backup_dir))
        print('Free space: {0} {1} size: {2}'.format(free, tarfilename, tarfileinfo.st_size))
        sys.exit(1)

    # Copy the tarfile to the backup_dir
    print('Copying tarfile to {0}/{1}'.format(opt.backup_dir, tarfilename))
    shutil.copy(tarfilename, opt.backup_dir)
    
    print('Removing temp dir {0}'.format(tmp_dir))
    shutil.rmtree(tmp_dir)
    

def run_slotsync_script():
    
    yes_list = ["y", "Y"]
    
    if not opt.force:
        #Verify user wants to run slotsync via Y/n input
        py3 = version_info[0] > 2 #creates boolean value for test that Python major version > 2
        if py3:
            response = input("Do you wish to sync these files to the alternate slot now? (Y/n):")
        else:
            response = raw_input("Do you wish to sync these files to the alternate slot now? (Y/n): ")
        
        if response.strip():
            if response.lstrip()[0] not in yes_list:
                print("Files will not be synced to the alternate slot")
                return
    #
    print('\nCalling ' + opt.slotsync_script + '  to copy config files to alternate slot\n')
    subprocess.call(opt.slotsync_script)


def shell_out(input_line):
    # Limitations:  1) Can't send pipes
    return subprocess.check_output(shlex.split(input_line))


def shell_call(input_line):
    # will raise error is return code is not zero
    subprocess.check_call(shlex.split(input_line))


def lvm_slotsync(inactive_slot):
    ## lvm storage (x86)
    mount_loc_pattern=re.compile('lvm\s+(\S+)')
    #convert to python or call code segment from here:
    inact_dev='^CUMULUS-SYSROOT{0}'.format(inactive_slot)
    inact_slot_pattern=re.compile(inact_dev)
    lsblk=shell_out('lsblk -r')
    for line in lsblk.split('\n'):
        if inact_slot_pattern.search(line):
            match=mount_loc_pattern.search(line)
            if match:
                #inactive slot already mounted
                return match.group[1]
            else:
                # slot not mounted - need to mount it
                inact_mount=shell_out('mktemp -dp /tmp -t slot' + inactive_slot + '_XXXX')
                shell_call('mount /dev/mapper/{0} {1}'.format(inact_dev, inact_mount))
                return inact_mount
                    
        else:
            print('Error: dev {0} not found in "lsblk -r" '.format(inact_dev))
            sys.exit()
    

def overlay_slotsync(inactive_slot):
    # Overlay storage (ppc)
    pass
    #Convert to python or call this code segment from here:
    '''
    source_slot_dir="/"
    target_slot_dir="/mnt/root-rw/config$inactive_slot"
    strip_dir_count=0

    # go ahead and clear the overlay since installation didn't do it for us
    rm -rf $target_slot_dir/*

    source /etc/cumulus/init/running/platform.conf
    if [[ $inactive_slot -eq 1 ]]; then
        inactive_ropart=$ro_part1
    else
        inactive_ropart=$ro_part2
    fi
    temp_ro_mount=$(mktemp -dp /tmp -t tmp_ro_mountXXXX )
    mount -t $ro_type -o $ro_opts /dev/$inactive_ropart $temp_ro_mount
    if ! diff $temp_ro_mount/etc/lsb-release "$target_slot_dir/etc/cumulus/init/lsb-release" &>/dev/null; then
        # init_rw_dir in the inactive slot's initramfs will clear the
        # overlay on firstboot, erasing the files we are about to copy
        # there. We have to initialize the overlay now to prevent this.
        # mount up the inactive ro, extract its initramfs, and chroot into
        # the functions we need.

        # Mount the inactive ro and extract initramfs from its uImage.
        # Assume initramfs is the first itb property value with "XZ
        # Compressed" magic number.  itb file format reference:
        # - https://git.kernel.org/cgit/utils/dtc/dtc.git/plain/Documentation/manual.txt?id=HEAD

        XZMAGIC=fd377a58
        STRUCT_POINTER_OFFSET=8

        uImage=$temp_ro_mount/boot/uImage.itb
        declare -A word

        map_word () {
            word[addr]=$1
            word[value]=$2
        }

        map_hex_word_at_cursor() {
            map_word $(hexdump -s$cursor -n4 -e '/4 "%_ad"' -e '/4 " %x"' $uImage)
        }

        map_uint_word_at_cursor() {
            map_word $(hexdump -s$cursor -n4 -e '/4 "%_ad"' -e '/4 " %u"' $uImage)
        }

        cursor_forward() {
            cursor=$(($cursor + $1))
        }

        # cursor = 0
        cursor=0

        # set cursor to location of struct pointer offset
        cursor_forward $STRUCT_POINTER_OFFSET
        # read structure offset (4 bytes), and move cursor to structure
        cursor=$(hexdump -s$cursor -n4 -e '/4 "%u"' $uImage)

        map_uint_word_at_cursor # read value at cursor

        # while true
        while true; do
            while [[ ${word[value]} -ne 3 ]]; do # while 4-byte uint at cursor not 3
                cursor_forward 4                 #     cursor forward four bytes
                map_uint_word_at_cursor          #     read 4-byte uint at cursor
            done
            cursor_forward 4                     # cursor forward 4 bytes
            map_uint_word_at_cursor              # read uint size (4 bytes)
            size=${word[value]}
            cursor_forward 8                     # cursor forward 8 bytes
            # if 4-bytes at cursor match 7zip magic
            #     dd from cursor to (cursor + size)
            #     exit
            # else
            #     cursor forward size bytes
            #     read value at cursor
            map_hex_word_at_cursor
            if [[ "${word[value]}" = "$XZMAGIC" ]];  then
                temp_initramfs=$(mktemp -p /tmp -t tmp_initramfsXXXX )
                dd if=$uImage of=$temp_initramfs bs=1 skip=${word[addr]} count=$size &>/dev/null
                break
            else
                cursor_forward $(($size + 4 - $size % 4))
                map_uint_word_at_cursor
            fi
        done

        # unpack with cpio from initramfs busybox tools under /mnt/initramfs
        temp_initramfs_mount=$(mktemp -dp /tmp -t tmp_initramfs_mountXXXX )
        mount -t tmpfs none $temp_initramfs_mount
        cd $temp_initramfs_mount && xzcat $temp_initramfs | /mnt/initramfs/bin/cpio -id 2>/dev/null && cd - > /dev/null
        # chroot into initramfs and run functions needed to initialize the
        # target overlay
        mkdir -p $target_slot_dir/etc/cumulus/init
        mkdir -p $temp_initramfs_mount/$target_slot_dir
        mkdir -p $temp_initramfs_mount/ro_mount
        mount -o bind,ro $temp_ro_mount $temp_initramfs_mount/ro_mount
        mount -o bind $target_slot_dir $temp_initramfs_mount/$target_slot_dir 
        mount -t proc none $temp_initramfs_mount/proc
        mount -o bind /dev $temp_initramfs_mount/dev
        chroot $temp_initramfs_mount /bin/sh -c "ro_rootmnt=ro_mount script_dir=scripts \
          source scripts/functions; make_fw_env_config; init_platform_path; init_rw_dir $target_slot_dir"
        cp $temp_ro_mount/etc/lsb-release $target_slot_dir/etc/cumulus/init/
    fi
fi

    
    '''
    return target_slot_dir
    
    
def slotsync(active_slot, inactive_slot, fstype, added_file_dct, changed_file_dct):
    pass
    dir_list=[]
    
    # Call appropriate routine for fstype
    if fstype=='overlay':
        target_slot_dir=overlay_slotsync(inactive_slot)
    elif fstype=='lvm':
        target_slot_dir=lvm_slotsync(inactive_slot)
    else:
        print('Error:  no matching file system type')
        sys.exit()
    
    #Note, dont' need to parse slotsync.conf, just make a list from combination of added
    # and changed_files_dct and write to an include file for the tarpipe.
    include_file=open(opt.slotsync_include, 'w')

    #Create list of directories to ensure tarpipe has proper ownership
    all_files_list=added_file_dct.keys() + changed_file_dct.keys()
    for file_to_include in sorted(all_files_list):
        file_dir=os.path.dirname(file_to_include)
        if file_dir not in dir_list:
          dir_list.append(file_dir)

    #Add list of dirs first, then all associated files
    for dir_name in sorted(dir_list):
        include_file.write('{0}\n'.format(dir_name))

    for file_to_include in sorted(all_files_list):
        include_file.write('{0}\n'.format(file_to_include))
        
    include_file.close()
    #print('\n' + opt.include_file + ' created.')

    # Tar pipe them:  May not want -m option, may not need --same-owner option
    #copied_file_list=shell_out('tar -cm -T {0} -f  --no-recursion ')
    copied_file_list=subprocess.check_output(['tar', '-cm', '-T', opt.slotsync_include, '-f', '-',
                                            '--no-recursion', '2>/dev/null', '|',
                                            'tar', '-C', target_slot_dir, '--same-owner', '-xvf', '-'])
    # Convert to python:
    '''
    
# create temporary files for parsing slotsync.conf
temp_include=$(mktemp --tmpdir=/tmp include.XXXXXX)
temp_exclude=$(mktemp --tmpdir=/tmp exclude.XXXXXX)

# always copy config file to other slot
echo "${source_slot_dir}${SYNC_CONFIG}" > "$temp_include"

# parse includes out of slotsync.conf
sed "/^-/d;                 # remove lines beginning with '-'
     s:#.*::;               # remove everything after a hash
     /^$/d;                 # delete empty lines
     s:\(^\s*\|\s*$\)::g;   # remove leading and trailing whitespace
     s:^:$source_slot_dir:  # prepend the source_slot_dir to every line" \
     "$SYNC_CONFIG" >> "$temp_include"

# excludes defaults, and append any configured excludes
# to be excluded with "tar -X"
echo "$exclude" | sed "s:^\s*::; /^$/d; s:^:$source_slot_dir:" > "$temp_exclude"
exclude_args="-X $temp_exclude"
if grep -q '^-' $SYNC_CONFIG; then
    sed -n "s:#.*::;                    # remove everything after a hash
            s:\(^\s*\|\s*$\)::g;        # remove leading and trailing whitespace
            s:/$::;                     # remove trailing slash
            /^-/s:^-:$source_slot_dir:p # on lines with '-', replace - with source_slot_dir
                                        #   then print the line" \
            "$SYNC_CONFIG" >> "$temp_exclude"
fi

# copy specified files and directories.  conceptually:
# "tar create from temp_include list (optionally excluding some) |tar extract to target_slot_dir"
file_list=$(
    tar -cmT "$temp_include" $exclude_args -f - 2>/dev/null |
    tar -C "$target_slot_dir" --strip-components="$strip_dir_count" -xvf -
)
file_count=$(($(echo "$file_list" |wc -l) -1))

mkdir -p $target_slot_dir/var/log
date >> $target_slot_dir/var/log/$(basename $0).log

cat - << EOUTPUT | tee -a $target_slot_dir/var/log/$(basename $0).log
Using config file: $SYNC_CONFIG
Copied the following files to slot $inactive_slot.

$(echo "$file_list" | sed 's:^:  /:')

$file_count files copied to slot $inactive_slot.
Slot $inactive_slot accessible under directory: $target_slot_dir/

Reminder: if used in the context of up/downgrade this script must be
used *after* cl-img-install in order to be effective.
EOUTPUT
    '''


def fixup_lldp_quagga():
    pass
    # look in cl-img-install -u code for files to run on first boot and put this there...
    #sudo chown _lldpd /usr/bin/lldpcli
    #sudo service restart
    #sudo chown quagga:quagga /var/log/quagga
    
    
def check_if_root_or_sudo():
    userid=os.geteuid()
    #print('EUID is: ' + str(userid))
    if userid!=0:
        print('Error:  This script must be run with sudo or as root')
        sys.exit()
    else:
        return
    

def check_if_mgmtvrf_or_netns():
    # Currently mgmtvrf or netns config could lock user out of box during upgrade.
    # need to check for it and decide how to error gracefully, or fix it
    # Here is shell code that needs to be convered to python and handling improved:
    '''
    if ip netns list | grep -q mgmt; then
      echo "Error: management namespace is enabled.  Unsupported configuration."
      exit 2
    fi
    if test -e /usr/sbin/cl-mgmtvrf && cl-mgmtvrf -s &>/dev/null ; then
      echo "Error: management VRF enabled.  Unsupported configuration."
    exit 2
    '''
    pass


def detect_fs_type(arch):
    # convert to python:
    '''# detect if using lvm (arm,x86) or overlay (ppc)
    rootdev=$(awk '$2 ~ /^\/$/ && $1 != "rootfs" {print $1}' /proc/mounts)
    case $rootdev in
        overlayfs:root)
            storage="overlayfs"
            ;;
        /dev*)
            if [[ $(basename $(readlink $rootdev)) =~ dm-[[:digit:]]+ ]]; then
                storage="lvm"
            else
                echo "Unknown storage type"
                exit 1
            fi
            ;;
        *)
            echo "Unknown storage type"
            exit 1
            ;;
    esac
'''
    pass
    #For now assume ppc is overlay and arm/x86 is lvm
    if arch == 'ppc':
        return 'overlayfs'
    if arch == 'arm' or arch == 'x86_64':
        return 'lvm'
        
    


def usage():
    
    print("Usage: " + sys.argv[0] + '[-b] [-d backupdirname] [-n] [-q] [-s] [-f] [-v] [-x] [-h]')
    print "\nDetermine changed config files. Optionally create backup archive or sync to other slot\n"
    print "{0:<15}: {1}".format(" no args", "Default: Print output of changed config files to screen")
    print "{0:<15}: {1}".format("-b, --backup", "Create a backup archive of changed config files. ")
    print "{0:<15}: {1}".format("-c, --create", "Create /etc/slotsync.conf - but don't call slotsync")
    print "{0:<15}: {1}".format("-d, --backup_dir [dir]", "Location to store backup archive. Default dir is /mnt/persist/backup")
    print "{0:<15}: {1}".format("-n, --dryrun", "Output to screen but don't create any files")
    print "{0:<15}: {1}".format("-q, --quiet", "No output to screen, only create any files requested ")    
    print "{0:<15}: {1}".format("-s, --sync", "Create /etc/slotsync.conf file and call slotsync to move file to alternate slot")
    print "{0:<15}: {1}".format("-f, --force", "Used with -s. Do not ask before running slotsync and moving files")
    print "{0:<15}: {1} {2}".format("-v, --debug", "Verbose: Write out debugging logs to", debug_fn)    
    print "{0:<15}: {1}".format("-x, --exclude dirs", "Exclude a comma separated list of dirs: e.g.  -x /root,/home")
    print "{0:<15}: {1}".format("-h, --help", "Show this message")


def parse_opts():

    try:
        opts, args = getopt.getopt(sys.argv[1:],"hbcdfnqsvx:",["help", "backup", "create", "backup_dir=",
                                                      "debug", "force", "dryrun",
                                                      "quiet", "sync", "exclude="])
    except getopt.GetoptError:
        usage()
        sys.exit(2)
    for opt_arg, arg in opts:
        if opt_arg in ('-h', '--help'):
            usage()
            sys.exit()
        elif opt_arg in ("-b", "--backup"):
            opt.backup=True
        elif opt_arg in ("-c", "--create"):
            opt.create=True
        elif opt_arg in ("-d", "--backup_dir"):
            opt.backup_dir=arg
        elif opt_arg in ("-v", "--debug"):
            opt.debug=open(opt.debug_fn, 'w')
        elif opt_arg in ("-f", "--force"):
            opt.force=True 
        elif opt_arg in ("-n", "--dryrun"):
            opt.dryrun=True
        elif opt_arg in ("-q", "--quiet"):
            opt.quiet=True
        elif opt_arg in ("-s", "--sync"):
            opt.create=True
            opt.sync=True
        elif opt_arg in ("-x", "--exclude"):
            #print('Exclude arg is {}'.format(arg))
            opt.exclude_list=arg.split(',')
            #print('Exclude list is {0}'.format(exclude_list))
        else:
            print("Bug: Unhandled option")
            sys.exit(1)

    if opt.debug and not opt.quiet:
        print('Created debug log file {0}'.format(opt.debug_fn))
    

def main():
    
    check_if_root_or_sudo()
    
    parse_opts()
    
    check_if_mgmtvrf_or_netns()
        
    # setup variables - debug(store data in local files), string lists
    install_list_dct={}
    local_list_dct={}
    added_file_dct={}
    changed_file_dct={}
    deleted_file_dct={}
    tmp_dir=None
    blank_line_pattern=re.compile('^\W*$')
    
    # Collect all the file data:
    # find and extract install file based on arch in uname -a
    arch=subprocess.check_output(['uname', '-m']).rstrip('\n')
    
    fstype=detect_fs_type(arch)
    active_slot, inactive_slot =get_slots()
    
    
    if arch == "ppc":
        install_list_dct, local_list_raw = get_ppc_files(active_slot)
        local_list_pattern=re.compile(r'''(?P<permissions>[rwxsStT-]+)
                                    \s+(?P<link_count>[0-9]+)
                                    \s+(?P<owner>\w+)
                                    \s+(?P<group>\w+)
                                    \s+(?P<size>\d+)
                                    \s+(?P<date>[0-9\-]+)
                                    \s+(?P<time>[0-9:]+)
                                    \.(?P<msec>[0-9]+)
                                    \s+(?P<timezone>[\+\-0-9]+)
                                    \s+
                                    '''+'/mnt/root\-rw/config'+active_slot+'(?P<filename>\S+)', re.X)
       
       
    #if arch == 'arm':
    #    #TBD - probably will look like x86
    #    pass
     
    
    if arch == 'x86_64' or arch == 'arm':
        install_list_dct, local_list_raw = get_x86_files()
        local_list_pattern=re.compile(r'''(?P<permissions>[rwxsStT-]+)
                                      \s+(?P<link_count>[0-9]+)
                                      \s+(?P<owner>\w+)
                                      \s+(?P<group>\w+)
                                      \s+(?P<size>\d+)
                                      \s+(?P<date>[0-9\-]+)
                                      \s+(?P<time>[0-9:]+)
                                      \.(?P<msec>[0-9]+)
                                      \s+(?P<timezone>[\+\-0-9]+)
                                      \s+(?P<filename>\S+)
                                      ''', re.X)
      
    
    
    # Loop through all local files and determine adds, changes, deletes. 
    for local_line in local_list_raw.split('\n'):
        comment=None
        match=local_list_pattern.match(local_line)
        if match:
            local_filename=match.group('filename')
            local_datetime='{} {}'.format(match.group('date'), match.group('time'))
            local_size=match.group('size')
            local_list_dct[local_filename]={ 'size': local_size, 'datetime' : local_datetime }
            if local_filename in install_list_dct:
                #File exists in both places.  Check to see if it has been modified
                install_datetime=install_list_dct[local_filename]['datetime']
                install_size=install_list_dct[local_filename]['size']
                if ( local_size != install_size) or ( local_datetime != install_datetime):
                    #File has been changed
                    changed_file_dct[local_filename]=''
     
            else:
                #local file not installed by installer, it is an added file
                added_file_dct[local_filename]=''

        elif blank_line_pattern.match(local_line):
            #Blank line. Ignore
            pass
        
        else:
            print('Error: Local filename, date, and size not parsed correctly.')
            print('Local Line: #'+local_line+'#')
            print('Decide what to do here... exit or continue')
     
    if opt.debug:
        opt.debug.write('\n------------------------------\nTemp added file list:\n')
        opt.debug.write(pformat(added_file_dct))
        opt.debug.write('\n------------------------------\nTemp changed file list:\n')
        opt.debug.write(pformat(changed_file_dct))
    
    # Cannot determine this on ppc, so only check x86
    # Loop through installed files and flag any files that have been deleted
    # This may be a pointless exercise and probably can be safely removed
    if arch=='x86_64':
        for install_filename in sorted(install_list_dct):
            if install_filename not in local_list_dct:
                deleted_file_dct[install_filename]="Note: File has been deleted since original binary install"
     
    
    # Loop through adds and compare to blacklist, whitelist.  Mark others as 3rd party
    added_file_dct=check_blacklist(added_file_dct)
    added_file_dct=check_exclude_list(added_file_dct)
    added_file_dct=check_whitelist(added_file_dct)
    
    # Loop through changes and compare to blacklist
    changed_file_dct=check_blacklist(changed_file_dct)
    changed_file_dct=check_exclude_list(changed_file_dct)
    # The only reason to check changed files against whitelist is to mark them with comments.
    # if they were changed and not blacklisted, they are important
    changed_file_dct=check_whitelist(changed_file_dct)
    
    
    # Loop through deletes and compare to blacklist, whitelist
    # No need at this time
    
    # output results to screen and a slotsync.conf file
    if not opt.quiet:
        print('Files Added since initial install:')
        for filename in sorted(added_file_dct):
            print('{0:<40}{1:<10} # {2}'.format(filename, local_list_dct[filename]['datetime'][0:10], added_file_dct[filename]))

        print('')
        print('Files Changed since initial install:')
        for filename in sorted(changed_file_dct):
            print('{0:<40}{1:<10} # {2}'.format(filename, local_list_dct[filename]['datetime'][0:10], changed_file_dct[filename]))
           
        if arch=='x86_64':    
            print('')
            print('Files Deleted since initial install:')
            for filename in sorted(deleted_file_dct):
                print('{0:<40}# {1}'.format(filename, deleted_file_dct[filename]))

    if opt.create and not opt.dryrun:
        create_slotsync_conf(added_file_dct, changed_file_dct)
        
    if opt.backup and not opt.dryrun:
        create_backup_tar(added_file_dct, changed_file_dct)

    if opt.debug:
        opt.debug.close()

    if opt.sync and not opt.dryrun:
        #run_slotsync_script()
        slotsync(active_slot, inactive_slot, fstype, added_file_dct, changed_file_dct)
        clean_mnt_persist()
        
    fixup_lldp_quagga()
    

if __name__ == '__main__':
    main()
    
